{
  "methods": {
    "在 Solana 链上搭建兑换应用#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n指南\n\n在 Solana 链上搭建兑换应用\n\n# 在 Solana 链上搭建兑换应用[#](#在-solana-链上搭建兑换应用)\n\n在 Solana 上使用OKX DEX构建兑换应用程序有两种方法：\n\n1.  API的方法-直接与OKX DEX API交互\n2.  SDK方法-使用 `@okx-dex/okx-dex-sdk`简化开发人员体验\n\n本指南涵盖了这两种方法，以帮助你选择最适合你需求的方法。\n\n## 方法1：API方法[#](#方法1：api方法)\n\n在本指南中，我们将提供通过OKX DEX进行Solana代币兑换的用例。\n\n## 1.设置环境[#](#1.设置环境)\n\n导入必要的Node. js库并设置环境变量：\n\n```typescript\n// Required libraries\nimport base58 from \"bs58\";\nimport BN from \"bn.js\";\nimport * as solanaWeb3 from \"@solana/web3.js\";\nimport { Connection } from \"@solana/web3.js\";\nimport cryptoJS from \"crypto-js\";\nimport axios from \"axios\";\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\n// Environment variables\nconst apiKey = process.env.OKX_API_KEY;\nconst secretKey = process.env.OKX_SECRET_KEY;\nconst apiPassphrase = process.env.OKX_API_PASSPHRASE;\nconst projectId = process.env.OKX_PROJECT_ID;\nconst userAddress = process.env.WALLET_ADDRESS;\nconst userPrivateKey = process.env.PRIVATE_KEY;\nconst solanaRpcUrl = process.env.SOLANA_RPC_URL;\n\n// Constants\nconst SOLANA_CHAIN_ID = \"501\";\nconst COMPUTE_UNITS = 300000;\nconst MAX_RETRIES = 3;\n\n// Initialize Solana connection\nconst connection = new Connection(`${solanaRpcUrl}`, {\n    confirmTransactionInitialTimeout: 5000\n});\n```\n\n```typescript\n// Utility function for OKX API authentication\nfunction getHeaders(timestamp: string, method: string, requestPath: string, queryString = \"\", body = \"\") {\n\n    const stringToSign = timestamp + method + requestPath + (queryString || body);\n    return {\n        \"Content-Type\": \"application/json\",\n        \"OK-ACCESS-KEY\": apiKey,\n        \"OK-ACCESS-SIGN\": cryptoJS.enc.Base64.stringify(\n            cryptoJS.HmacSHA256(stringToSign, secretKey)\n        ),\n        \"OK-ACCESS-TIMESTAMP\": timestamp,\n        \"OK-ACCESS-PASSPHRASE\": apiPassphrase,\n        \"OK-ACCESS-PROJECT\": projectId,\n    };\n}\n```\n\n## 2.获取兑换数据[#](#2.获取兑换数据)\n\nSolana的本机令牌地址11111111111111111111111111111111。使用/swap端点检索详细的兑换信息：\n\n```typescript\nasync function getSwapData(\n    fromTokenAddress: string, \n    toTokenAddress: string, \n    amount: string, \n    slippage = '0.005' // 0.5% slippage\n) {\n    const timestamp = new Date().toISOString();\n    const requestPath = \"/api/v5/dex/aggregator/swap\";\n\n    const params = {\n        amount: amount,\n        chainId: SOLANA_CHAIN_ID,\n        fromTokenAddress: fromTokenAddress,\n        toTokenAddress: toTokenAddress,\n        userWalletAddress: userAddress,\n        slippage: slippage\n    };\n\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\n\n    try {\n        const response = await axios.get(\n            `https://web3.okx.com${requestPath}${queryString}`,\n            { headers }\n        );\n\n        if (response.data.code !== \"0\" || !response.data.data?.[0]) {\n            throw new Error(`API Error: ${response.data.msg || \"Failed to get swap data\"}`);\n        }\n\n        return response.data.data[0];\n    } catch (error) {\n        console.error(\"Error fetching swap data:\", error);\n        throw error;\n    }\n}\n```\n\n## 3.准备交易[#](#3.准备交易)\n\n```typescript\nasync function prepareTransaction(callData: string) {\n    try {\n        // Decode the base58 encoded transaction data\n        const decodedTransaction = base58.decode(callData);\n        \n        // Get the latest blockhash\n        const recentBlockHash = await connection.getLatestBlockhash();\n        console.log(\"Got blockhash:\", recentBlockHash.blockhash);\n        \n        let tx;\n        \n        // Try to deserialize as a versioned transaction first\n        try {\n            tx = solanaWeb3.VersionedTransaction.deserialize(decodedTransaction);\n            console.log(\"Successfully created versioned transaction\");\n            tx.message.recentBlockhash = recentBlockHash.blockhash;\n        } catch (e) {\n            // Fall back to legacy transaction if versioned fails\n            console.log(\"Versioned transaction failed, trying legacy:\", e);\n            tx = solanaWeb3.Transaction.from(decodedTransaction);\n            console.log(\"Successfully created legacy transaction\");\n            tx.recentBlockhash = recentBlockHash.blockhash;\n        }\n        \n        return {\n            transaction: tx,\n            recentBlockHash\n        };\n    } catch (error) {\n        console.error(\"Error preparing transaction:\", error);\n        throw error;\n    }\n}\n```\n\n## 4\\. 模拟交易[#](#4.-模拟交易)\n\n在执行实际兑换之前，务必模拟交易以确保其成功并识别任何潜在问题：\n\n此功能使用 `交易上链 API`。此 API 仅供我们的白名单客户使用。如您感兴趣，请联系我们 [dexapi@okx.com](mailto:dexapi@okx.com)。\n\n```typescript\nasync function simulateTransaction(swapData: any) {\n    try {\n        if (!swapData.tx) {\n            throw new Error('Invalid swap data format - missing transaction data');\n        }\n\n        const tx = swapData.tx;\n        const params: any = {\n            fromAddress: tx.from,\n            toAddress: tx.to,\n            txAmount: tx.value,\n            chainIndex: SOLANA_CHAIN_ID,\n            extJson: {\n                inputData: tx.data\n            },\n            includeDebug: true\n        };\n\n        const timestamp = new Date().toISOString();\n        const requestPath = \"/api/v5/dex/pre-transaction/simulate\";\n        const requestBody = JSON.stringify(params);\n        const headers = getHeaders(timestamp, \"POST\", requestPath, \"\", requestBody);\n\n        console.log('Simulating transaction...');\n        const response = await axios.post(\n            `https://web3.okx.com${requestPath}`, \n            params, \n            { headers }\n        );\n\n        if (response.data.code !== \"0\") {\n            throw new Error(`Simulation failed: ${response.data.msg || \"Unknown simulation error\"}`);\n        }\n\n        const simulationResult = response.data.data[0];\n        \n        // Check simulation success\n        if (simulationResult.success === false) {\n            console.error('Transaction simulation failed:', simulationResult.error);\n            throw new Error(`Transaction would fail: ${simulationResult.error}`);\n        }\n\n        console.log('Transaction simulation successful');\n        console.log(`Estimated gas used: ${simulationResult.gasUsed || 'N/A'}`);\n        \n        if (simulationResult.logs) {\n            console.log('Simulation logs:', simulationResult.logs);\n        }\n\n        return simulationResult;\n    } catch (error) {\n        console.error(\"Error simulating transaction:\", error);\n        throw error;\n    }\n}\n```\n\n## 5\\. 广播交易[#](#5.-广播交易)\n\n5.1 使用 `RPC` 广播交易 Solana 使用计算单元（而非 Gas）来衡量交易复杂度。有两种方法可以估算交易的计算单元：使用标准 RPC 调用或利用 交易上链API。\n\n方法 1：使用 交易上链 API 进行计算单元估算\n\n第一种方法利用 OKX 的交易上链 API，该 API 提供比标准方法更准确的计算单元估算。\n\n```typescript\n/**\n * Get transaction compute units from 交易上链 API\n * @param fromAddress - Sender address\n * @param toAddress - Target program address\n * @param inputData - Transaction data (base58 encoded)\n * @returns Estimated compute units\n */\nasync function getComputeUnits(\n    fromAddress: string,\n    toAddress: string,\n    inputData: string\n): Promise<number> {\n    try {\n        const path = 'dex/pre-transaction/gas-limit';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            chainIndex: \"501\", // Solana chain ID\n            fromAddress: fromAddress,\n            toAddress: toAddress,\n            txAmount: \"0\",\n            extJson: {\n                inputData: inputData\n            }\n        };\n\n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const computeUnits = parseInt(response.data.data[0].gasLimit);\n            console.log(`API estimated compute units: ${computeUnits}`);\n            return computeUnits;\n        } else {\n            throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Failed to get compute units from API:', (error as Error).message);\n        throw error;\n    }\n}\n```\n\n方法 2：使用 RPC 估算计算单元\n\n第二种方法利用标准 Solana RPC 调用来模拟和估算交易所需的计算单元。\n\n```typescript\n/**\n * Estimate compute units for a transaction\n */\nasync function getComputeUnits(transaction: VersionedTransaction): Promise<number> {\n    try {\n        // Simulate the transaction to get compute unit usage\n        const simulationResult = await connection.simulateTransaction(transaction, {\n            replaceRecentBlockhash: true,\n            commitment: 'processed'\n        });\n\n        if (simulationResult.value.err) {\n            throw new Error(`Simulation failed: ${JSON.stringify(simulationResult.value.err)}`);\n        }\n\n        // Get the compute units consumed from simulation\n        const computeUnitsConsumed = simulationResult.value.unitsConsumed || 200000;\n        \n        // Add 20% buffer for safety\n        const computeUnitsWithBuffer = Math.ceil(computeUnitsConsumed * 1.2);\n        \n        console.log(`Estimated compute units: ${computeUnitsConsumed}`);\n        console.log(`With 20% buffer: ${computeUnitsWithBuffer}`);\n        \n        return computeUnitsWithBuffer;\n    } catch (error) {\n        console.warn('Failed to estimate compute units, using default:', error);\n        return 300000; // Default fallback\n    }\n}\n```\n\n5.2 使用计算单元准备交易\n\n广播前，请使用预估的计算单元和最新的区块哈希值准备您的交易：\n\n方法 1：使用 Gas-Limit API 的计算单元准备交易\n\n使用交易上链 API 中预估的计算单元准备您的交易：\n\n```typescript\n/**\n * Get transaction compute units from 交易上链 API\n */\nasync function getComputeUnitsFromAPI(\n    fromAddress: string,\n    inputData: string\n): Promise<number> {\n    try {\n        const path = 'dex/pre-transaction/gas-limit';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            chainIndex: \"501\", // Solana chain ID\n            fromAddress: fromAddress,\n            toAddress: \"\", // Can be empty for Solana\n            txAmount: \"0\",\n            extJson: {\n                inputData: inputData\n            }\n        };\n\n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: bodyString\n        });\n\n        const data = await response.json();\n\n        if (data.code === '0') {\n            const computeUnits = parseInt(data.data[0].gasLimit);\n            console.log(`API estimated compute units: ${computeUnits}`);\n            return computeUnits;\n        } else {\n            throw new Error(`API Error: ${data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Failed to get compute units from API:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Prepare transaction with compute units from API\n */\nasync function prepareTransactionWithAPIComputeUnits(\n    transaction: VersionedTransaction,\n    fromAddress: string,\n    transactionData: string\n): Promise<{\n    transaction: VersionedTransaction;\n    gasData: {\n        estimatedComputeUnits: number;\n        priorityFee: number;\n        blockhash: string;\n    };\n}> {\n    try {\n        // Get fresh blockhash\n        const { blockhash } = await connection.getLatestBlockhash('confirmed');\n        console.log(`Using blockhash: ${blockhash}`);\n        \n        // Update the transaction's blockhash\n        transaction.message.recentBlockhash = blockhash;\n        \n        // Check if transaction already has compute budget instructions\n        const hasComputeBudgetIx = transaction.message.compiledInstructions.some(ix => {\n            const programId = transaction.message.staticAccountKeys[ix.programIdIndex];\n            return programId.equals(ComputeBudgetProgram.programId);\n        });\n        \n        if (hasComputeBudgetIx) {\n            console.log('Transaction already contains compute budget instructions, skipping addition');\n            return { \n                transaction, \n                gasData: {\n                    estimatedComputeUnits: 300000,\n                    priorityFee: 1000,\n                    blockhash\n                }\n            };\n        }\n        \n        // Get compute units from API\n        const estimatedComputeUnits = await getComputeUnitsFromAPI(fromAddress, transactionData);\n        \n        // Set priority fee\n        const priorityFee = 1000; // microLamports\n        \n        const gasData = {\n            estimatedComputeUnits,\n            priorityFee,\n            blockhash\n        };\n        \n        console.log(`Priority fee: ${gasData.priorityFee} microLamports`);\n        \n        // Create compute unit limit instruction\n        const computeBudgetIx = ComputeBudgetProgram.setComputeUnitLimit({\n            units: gasData.estimatedComputeUnits\n        });\n        \n        // Create compute unit price instruction for priority\n        const computePriceIx = ComputeBudgetProgram.setComputeUnitPrice({\n            microLamports: gasData.priorityFee\n        });\n        \n        // Get existing instructions and account keys\n        const existingInstructions = [...transaction.message.compiledInstructions];\n        const existingAccountKeys = [...transaction.message.staticAccountKeys];\n        \n        // Add compute budget program to account keys if not present\n        let computeBudgetProgramIndex = existingAccountKeys.findIndex(\n            key => key.equals(ComputeBudgetProgram.programId)\n        );\n        \n        if (computeBudgetProgramIndex === -1) {\n            computeBudgetProgramIndex = existingAccountKeys.length;\n            existingAccountKeys.push(ComputeBudgetProgram.programId);\n        }\n        \n        // Create new instructions array with compute budget instructions\n        const newInstructions = [\n            {\n                programIdIndex: computeBudgetProgramIndex,\n                accountKeyIndexes: [],\n                data: computeBudgetIx.data\n            },\n            {\n                programIdIndex: computeBudgetProgramIndex,\n                accountKeyIndexes: [],\n                data: computePriceIx.data\n            },\n            ...existingInstructions\n        ];\n        \n        // Create new versioned message with proper instruction mapping\n        const newMessage = new TransactionMessage({\n            payerKey: existingAccountKeys[0],\n            recentBlockhash: gasData.blockhash,\n            instructions: newInstructions.map(ix => ({\n                programId: existingAccountKeys[ix.programIdIndex],\n                keys: ix.accountKeyIndexes.map(idx => ({\n                    pubkey: existingAccountKeys[idx],\n                    isSigner: false,\n                    isWritable: false\n                })).filter(key => key.pubkey),\n                data: Buffer.from(ix.data)\n            })).filter(ix => ix.programId)\n        }).compileToV0Message();\n        \n        // Create and return new transaction\n        const preparedTransaction = new VersionedTransaction(newMessage);\n        return { transaction: preparedTransaction, gasData };\n    } catch (error) {\n        console.error('Error preparing transaction:', error);\n        throw error;\n    }\n}\n```\n\n方法 2：使用 RPC 的计算单元准备交易\n\n```typescript\n// Simple connection setup\nconst connection = new Connection(\n    process.env.SOLANA_RPC_URL || \"https://api.mainnet-beta.solana.com\"\n);\n\n/**\n * Prepare transaction with compute units\n */\nasync function prepareTransactionWithComputeUnits(\n    transaction: VersionedTransaction\n): Promise<{\n    transaction: VersionedTransaction;\n    gasData: {\n        estimatedComputeUnits: number;\n        priorityFee: number;\n        blockhash: string;\n    };\n}> {\n    try {\n        // Get fresh blockhash\n        const { blockhash } = await connection.getLatestBlockhash('confirmed');\n        console.log(`Using blockhash: ${blockhash}`);\n        \n        // Update the transaction's blockhash\n        transaction.message.recentBlockhash = blockhash;\n        \n        // Check if transaction already has compute budget instructions\n        const hasComputeBudgetIx = transaction.message.compiledInstructions.some(ix => {\n            const programId = transaction.message.staticAccountKeys[ix.programIdIndex];\n            return programId.equals(ComputeBudgetProgram.programId);\n        });\n        \n        if (hasComputeBudgetIx) {\n            console.log('Transaction already contains compute budget instructions, skipping addition');\n            return { \n                transaction, \n                gasData: {\n                    estimatedComputeUnits: 300000,\n                    priorityFee: 1000,\n                    blockhash\n                }\n            };\n        }\n        \n        // Estimate compute units\n        const estimatedComputeUnits = await getComputeUnits(transaction);\n        \n        // Set priority fee\n        const priorityFee = 1000; // microLamports\n        \n        const gasData = {\n            estimatedComputeUnits,\n            priorityFee,\n            blockhash\n        };\n        \n        console.log(`Priority fee: ${gasData.priorityFee} microLamports`);\n        \n        // Create compute unit limit instruction\n        const computeBudgetIx = ComputeBudgetProgram.setComputeUnitLimit({\n            units: gasData.estimatedComputeUnits\n        });\n        \n        // Create compute unit price instruction for priority\n        const computePriceIx = ComputeBudgetProgram.setComputeUnitPrice({\n            microLamports: gasData.priorityFee\n        });\n        \n        // Get existing instructions and account keys\n        const existingInstructions = [...transaction.message.compiledInstructions];\n        const existingAccountKeys = [...transaction.message.staticAccountKeys];\n        \n        // Add compute budget program to account keys if not present\n        let computeBudgetProgramIndex = existingAccountKeys.findIndex(\n            key => key.equals(ComputeBudgetProgram.programId)\n        );\n        \n        if (computeBudgetProgramIndex === -1) {\n            computeBudgetProgramIndex = existingAccountKeys.length;\n            existingAccountKeys.push(ComputeBudgetProgram.programId);\n        }\n        \n        // Create new instructions array with compute budget instructions\n        const newInstructions = [\n            {\n                programIdIndex: computeBudgetProgramIndex,\n                accountKeyIndexes: [],\n                data: computeBudgetIx.data\n            },\n            {\n                programIdIndex: computeBudgetProgramIndex,\n                accountKeyIndexes: [],\n                data: computePriceIx.data\n            },\n            ...existingInstructions\n        ];\n        \n        // Create new versioned message with proper instruction mapping\n        const newMessage = new TransactionMessage({\n            payerKey: existingAccountKeys[0],\n            recentBlockhash: gasData.blockhash,\n            instructions: newInstructions.map(ix => ({\n                programId: existingAccountKeys[ix.programIdIndex],\n                keys: ix.accountKeyIndexes.map(idx => ({\n                    pubkey: existingAccountKeys[idx],\n                    isSigner: false,\n                    isWritable: false\n                })).filter(key => key.pubkey),\n                data: Buffer.from(ix.data)\n            })).filter(ix => ix.programId)\n        }).compileToV0Message();\n        \n        // Create and return new transaction\n        const preparedTransaction = new VersionedTransaction(newMessage);\n        return { transaction: preparedTransaction, gasData };\n    } catch (error) {\n        console.error('Error preparing transaction:', error);\n        throw error;\n    }\n}\n```\n\n5.3 使用`交易上链 API`广播交易 使用 交易上链 API 对于拥有 交易上链 API 访问权限的开发者，您可以直接通过 OKX 的基础设施广播交易。此方法可为高交易量操作提供增强的可靠性和监控能力。\n\n广播 API 针对白名单客户开放。请联系 [dexapi@okx.com](mailto:dexapi@okx.com) 申请访问权限。\n\n```typescript\nasync function broadcastTransaction(\n    signedTx: solanaWeb3.Transaction | solanaWeb3.VersionedTransaction\n) {\n    try {\n        const serializedTx = signedTx.serialize();\n        const encodedTx = base58.encode(serializedTx);\n        \n        const path = \"dex/pre-transaction/broadcast-transaction\";\n        const url = `https://web3.okx.com/api/v5/${path}`;\n        \n        const broadcastData = {\n            signedTx: encodedTx,\n            chainIndex: SOLANA_CHAIN_ID,\n            address: userAddress\n            // See [MEV Section](#8-mev-protection) for MEV protection settings\n        };\n        \n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(broadcastData);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n        \n        const response = await axios.post(url, broadcastData, { headers });\n        \n        if (response.data.code === '0') {\n            const orderId = response.data.data[0].orderId;\n            console.log(`Transaction broadcast successfully, Order ID: ${orderId}`);\n\n            return orderId;\n        } else {\n            throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Failed to broadcast transaction:', error);\n        throw error;\n    }\n}\n```\n\nUsing Standard RPC For developers who prefer using standard blockchain RPC methods or do not have yet requested API whitelisting, you can broadcast transactions directly to the network using Web3 RPC calls.\n\n```typescript\nasync function signAndBroadcastTransaction(\n    tx: solanaWeb3.Transaction | solanaWeb3.VersionedTransaction,\n    connection: Connection\n) {\n    if (!userPrivateKey) {\n        throw new Error(\"Private key not found\");\n    }\n    \n    const feePayer = solanaWeb3.Keypair.fromSecretKey(\n        base58.decode(userPrivateKey)\n    );\n    \n    // Sign the transaction\n    if (tx instanceof solanaWeb3.VersionedTransaction) {\n        tx.sign([feePayer]);\n    } else {\n        tx.partialSign(feePayer);\n    }\n    \n    // Send the transaction with retry logic\n    const maxRetries = 3;\n    let attempt = 0;\n    \n    while (attempt < maxRetries) {\n        try {\n            const txId = await connection.sendRawTransaction(tx.serialize(), {\n                skipPreflight: false,\n                preflightCommitment: 'processed',\n                maxRetries: 0 // Handle retries manually\n            });\n            \n            console.log(`Transaction sent: ${txId}`);\n            \n            // Wait for confirmation with timeout\n            const confirmation = await connection.confirmTransaction({\n                signature: txId,\n                blockhash: tx instanceof solanaWeb3.VersionedTransaction \n                    ? tx.message.recentBlockhash \n                    : tx.recentBlockhash!,\n                lastValidBlockHeight: tx instanceof solanaWeb3.VersionedTransaction \n                    ? undefined \n                    : tx.lastValidBlockHeight!\n            }, 'confirmed');\n            \n            if (confirmation.value.err) {\n                throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n            }\n            \n            console.log(`Transaction confirmed: https://solscan.io/tx/${txId}`);\n            return txId;\n            \n        } catch (error) {\n            attempt++;\n            console.warn(`Attempt ${attempt} failed:`, error);\n            \n            if (attempt >= maxRetries) {\n                throw new Error(`Transaction failed after ${maxRetries} attempts: ${error}`);\n            }\n            \n            // Wait before retry\n            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));\n        }\n    }\n}\n```\n\n### Swap Transaction Using Compute Unit Data[#](#swap-transaction-using-compute-unit-data)\n\nHere's a complete example that demonstrates the full flow from getting swap data to preparing transactions with proper compute unit estimation:\n\n```typescript\nimport { getHeaders } from '../../shared';\nimport {\n    Connection,\n    VersionedTransaction,\n    ComputeBudgetProgram,\n    TransactionMessage\n} from \"@solana/web3.js\";\nimport base58 from 'bs58';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\n// Simple connection to one RPC endpoint\nconst connection = new Connection(\n    process.env.SOLANA_RPC_URL || \"https://api.mainnet-beta.solana.com\"\n);\n\nasync function getQuote(params: any) {\n    const timestamp = new Date().toISOString();\n    const requestPath = \"/api/v5/dex/aggregator/swap\";\n    const queryString = \"?\" + new URLSearchParams({\n        ...params,\n    }).toString();\n\n    const headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\n    const response = await fetch(`https://web3.okx.com${requestPath}${queryString}`, {\n        method: \"GET\",\n        headers\n    });\n\n    const data = await response.json();\n    return data;\n}\n\n/**\n * * Get compute units using 交易上链API (API registration and whitelist required)\n */\nasync function getComputeUnitsFromAPI(\n    fromAddress: string,\n    inputData: string\n): Promise<number> {\n    try {\n        const path = 'dex/pre-transaction/gas-limit';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            chainIndex: \"501\", // Solana chain ID\n            fromAddress: fromAddress,\n            toAddress: \"\", // Can be empty for Solana\n            txAmount: \"0\",\n            extJson: {\n                inputData: inputData\n            }\n        };\n\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await fetch(url, {\n            method: 'POST',\n            headers,\n            body: bodyString\n        });\n\n        const data = await response.json();\n\n        if (data.code === '0') {\n            const computeUnits = parseInt(data.data[0].gasLimit);\n            console.log(`API estimated compute units: ${computeUnits}`);\n            return computeUnits;\n        } else {\n            throw new Error(`API Error: ${data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Failed to get compute units from API, falling back to simulation:', error);\n        // Fallback to RPC simulation\n        return 300000;\n    }\n}\n\n/**\n * Execute a complete Solana transaction with proper compute unit estimation\n */\nasync function executeTransaction(): Promise<{\n    quote: any;\n    gasData: {\n        estimatedComputeUnits: number;\n        priorityFee: number;\n        blockhash: string;\n    };\n    preparedTransaction: string;\n}> {\n    try {\n        console.log('Getting Solana swap data...');\n\n        // Step 1: Get swap data from OKX DEX API\n        const quote = await getQuote({\n            chainId: '501', // Solana chain ID\n            amount: '10000000', // 0.01 SOL in lamports\n            fromTokenAddress: '11111111111111111111111111111111', // SOL\n            toTokenAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n            userWalletAddress: \"YOUR_WALLET_ADDRESS\",\n            slippage: '0.1',\n            autoSlippage: \"true\",\n            maxAutoSlippageBps: \"100\"\n        });\n\n        console.log('Quote response:', JSON.stringify(quote, null, 2));\n\n        // Step 2: Process transaction data if available\n        if (quote.data && quote.data[0] && quote.data[0].tx && quote.data[0].tx.data) {\n            console.log('\\nGetting gas data for transaction...');\n            \n            // Step 3: Create transaction from the data\n            const decodedTransaction = base58.decode(quote.data[0].tx.data);\n            const transaction = VersionedTransaction.deserialize(decodedTransaction);\n            \n            // Step 4: Get compute units using API (API whitelist required) or fallback to RPC \n            const userWalletAddress = \"YOUR_WALLET_ADDRESS\";\n            let estimatedComputeUnits: number;\n            \n            try {\n                // Try API first (API whitelist required)\n                estimatedComputeUnits = await getComputeUnitsFromAPI(\n                    userWalletAddress,\n                    quote.data[0].tx.data\n                );\n                console.log('Using API estimate for compute units');\n            } catch (error) {\n                // Fallback to RPC simulation\n                estimatedComputeUnits = await getComputeUnits(transaction);\n                console.log('Using RPC simulation for compute units');\n            }\n            \n            // Step 5: Prepare transaction with compute units\n            const { transaction: preparedTransaction, gasData } = await prepareTransactionWithComputeUnits(transaction);\n            \n            // Override with API estimate if we got one\n            gasData.estimatedComputeUnits = estimatedComputeUnits;\n            \n            console.log('\\nGas Data Summary:');\n            console.log('Blockhash:', gasData.blockhash);\n            console.log('Estimated Compute Units:', gasData.estimatedComputeUnits);\n            console.log('Priority Fee:', gasData.priorityFee, 'microLamports');\n            console.log('Transaction prepared successfully');\n            \n            // Return the complete result\n            const result = {\n                quote: quote.data[0],\n                gasData,\n                preparedTransaction: Buffer.from(preparedTransaction.serialize()).toString('base64')\n            };\n            \n            console.log('\\nFinal Result:', JSON.stringify(result, null, 2));\n            return result;\n        } else {\n            throw new Error('No transaction data received from swap API');\n        }\n    } catch (error) {\n        console.error(\"Error executing transaction:\", error);\n        throw error;\n    }\n}\n\n// Example usage\nasync function main() {\n    try {\n        await executeTransaction();\n    } catch (error) {\n        console.error('Failed to prepare transaction:', error);\n        process.exit(1);\n    }\n}\n\n// Run if this file is executed directly\nif (require.main === module) {\n    main();\n}\n\nexport { executeTransaction, prepareTransactionWithComputeUnits, getComputeUnits, getComputeUnitsFromAPI };\n```\n\n## 6.追踪交易[#](#6.追踪交易)\n\n最后，创建一个交易追踪系统，对于基本交易的状态确认，请选择第一个（6.1 部分）；当您需要有关兑换执行本身的详细信息时，请选择第二个（6.2部分）。\n\n6.1 使用 交易上链 API 交易上链 API 通过 `/dex/post-transaction/orders` 提供交易追踪功能。使用广播 API 返回的订单ID，并设置简单的状态代码（1：待处理，2：成功，3：失败），即可追踪交易在 OKX 系统中的进展。\n\n```typescript\n// Define transaction status interface\ninterface TxErrorInfo {\n    error: string;\n    message: string;\n    action: string;\n}\n\n/**\n * Tracking transaction confirmation status using the Onchain gateway API\n * @param orderId - Order ID from broadcast response\n * @param intervalMs - Polling interval in milliseconds\n * @param timeoutMs - Maximum time to wait\n * @returns Final transaction confirmation status\n */\nasync function trackTransaction(\n    orderId: string,\n    intervalMs: number = 5000,\n    timeoutMs: number = 300000\n): Promise<any> {\n    console.log(`Tracking transaction with Order ID: ${orderId}`);\n\n    const startTime = Date.now();\n    let lastStatus = '';\n\n    while (Date.now() - startTime < timeoutMs) {\n        // Get transaction status\n        try {\n            const path = 'dex/post-transaction/orders';\n            const url = `https://web3.okx.com/api/v5/${path}`;\n\n            const params = {\n                orderId: orderId,\n                chainIndex: SOLANA_CHAIN_ID,\n                address: userAddress,\n                limit: '1'\n            };\n\n            // Prepare authentication\n            const timestamp = new Date().toISOString();\n            const requestPath = `/api/v5/${path}`;\n            const queryString = \"?\" + new URLSearchParams(params).toString();\n            const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n            const response = await axios.get(url, { params, headers });\n            \n            if (response.data.code === '0' && response.data.data && response.data.data.length > 0) {\n                if (response.data.data[0].orders && response.data.data[0].orders.length > 0) {\n                    const txData = response.data.data[0].orders[0];\n                    \n                    // Use txStatus to match the API response\n                    const status = txData.txStatus;\n\n                    // Only log when status changes\n                    if (status !== lastStatus) {\n                        lastStatus = status;\n\n                        if (status === '1') {\n                            console.log(`Transaction pending: ${txData.txHash || 'Hash not available yet'}`);\n                        } else if (status === '2') {\n                            console.log(`Transaction successful: https://solscan.io/tx/${txData.txHash}`);\n                            return txData;\n                        } else if (status === '3') {\n                            const failReason = txData.failReason || 'Unknown reason';\n                            const errorMessage = `Transaction failed: ${failReason}`;\n\n                            console.error(errorMessage);\n\n                            const errorInfo = handleTransactionError(txData);\n                            console.log(`Error type: ${errorInfo.error}`);\n                            console.log(`Suggested action: ${errorInfo.action}`);\n\n                            throw new Error(errorMessage);\n                        }\n                    }\n                } else {\n                    console.log(`No orders found for Order ID: ${orderId}`);\n                }\n            }\n        } catch (error) {\n            console.warn('Error checking transaction status:', (error instanceof Error ? error.message : \"Unknown error\"));\n        }\n\n        // Wait before next check\n        await new Promise(resolve => setTimeout(resolve, intervalMs));\n    }\n\n    throw new Error('Transaction tracking timed out');\n}\n\n/**\n * Comprehensive error handling with failReason\n * @param txData - Transaction data from post-transaction/orders\n * @returns Structured error information\n */\nfunction handleTransactionError(txData: any): TxErrorInfo {\n    const failReason = txData.failReason || 'Unknown reason';\n\n    // Log the detailed error\n    console.error(`Transaction failed with reason: ${failReason}`);\n\n    // Default error info\n    let errorInfo: TxErrorInfo = {\n        error: 'TRANSACTION_FAILED',\n        message: failReason,\n        action: 'Try again or contact support'\n    };\n\n    // More specific error handling based on the failure reason\n    if (failReason.includes('insufficient funds')) {\n        errorInfo = {\n            error: 'INSUFFICIENT_FUNDS',\n            message: 'Your wallet does not have enough funds to complete this transaction',\n            action: 'Add more SOL to your wallet to cover the transaction'\n        };\n    } else if (failReason.includes('blockhash')) {\n        errorInfo = {\n            error: 'BLOCKHASH_EXPIRED',\n            message: 'The transaction blockhash has expired',\n            action: 'Try again with a fresh transaction'\n        };\n    } else if (failReason.includes('compute budget')) {\n        errorInfo = {\n            error: 'COMPUTE_BUDGET_EXCEEDED',\n            message: 'Transaction exceeded compute budget',\n            action: 'Increase compute units or simplify the transaction'\n        };\n    }\n\n    return errorInfo;\n}\n```\n\n6.2 如需更详细的兑换信息，您可以使用 SWAP API：\n\nSWAP API 使用 `/dex/aggregator/history` 提供全面交易跟踪\n\n```typescript\n/**\n * Track transaction using SWAP API\n * @param chainId - Chain ID (e.g., 501 for Solana)\n * @param txHash - Transaction hash\n * @returns Transaction details\n */\nasync function trackTransactionWithSwapAPI(\n    txHash: string\n): Promise<any> {\n    try {\n        const path = 'dex/aggregator/history';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const params = {\n            chainId: SOLANA_CHAIN_ID,\n            txHash: txHash,\n            isFromMyProject: 'true'\n        };\n\n        // Prepare authentication\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const queryString = \"?\" + new URLSearchParams(params).toString();\n        const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n        const response = await axios.get(url, { params, headers });\n\n        if (response.data.code === '0') {\n            const txData = response.data.data[0];\n            const status = txData.status;\n\n            if (status === 'pending') {\n                console.log(`Transaction is still pending: ${txHash}`);\n                return { status: 'pending', details: txData };\n            } else if (status === 'success') {\n                console.log(`Transaction successful!`);\n                console.log(`From: ${txData.fromTokenDetails.symbol} - Amount: ${txData.fromTokenDetails.amount}`);\n                console.log(`To: ${txData.toTokenDetails.symbol} - Amount: ${txData.toTokenDetails.amount}`);\n                console.log(`Transaction Fee: ${txData.txFee}`);\n                console.log(`Explorer URL: https://solscan.io/tx/${txHash}`);\n                return { status: 'success', details: txData };\n            } else if (status === 'failure') {\n                console.error(`Transaction failed: ${txData.errorMsg || 'Unknown reason'}`);\n                return { status: 'failure', details: txData };\n            }\n            \n            return txData;\n        } else {\n            throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Failed to track transaction status:', (error instanceof Error ? error.message : \"Unknown error\"));\n        throw error;\n    }\n}\n```\n\n## 7.完整实现[#](#7.完整实现)\n\n这是一个完整的实现示例：\n\n```typescript\nimport { getHeaders } from '../../shared';\nimport { Connection, PublicKey, Transaction, Keypair, VersionedTransaction, SystemProgram } from '@solana/web3.js';\nimport * as axios from 'axios';\nimport bs58 from 'bs58';\n\n// // Utility function for OKX API authentication\n// function getHeaders(timestamp: string, method: string, requestPath: string, queryString = \"\", body = \"\") {\n//    const stringToSign = timestamp + method + requestPath + (queryString || body);\n//    return {\n//        \"Content-Type\": \"application/json\",\n//        \"OK-ACCESS-KEY\": apiKey,\n//        \"OK-ACCESS-SIGN\": cryptoJS.enc.Base64.stringify(\n//            cryptoJS.HmacSHA256(stringToSign, secretKey)\n//        ),\n//        \"OK-ACCESS-TIMESTAMP\": timestamp,\n//        \"OK-ACCESS-PASSPHRASE\": apiPassphrase,\n//        \"OK-ACCESS-PROJECT\": projectId,\n//    };\n\n// Environment variables\nconst WALLET_ADDRESS = process.env.SOLANA_WALLET_ADDRESS;\nconst PRIVATE_KEY = process.env.SOLANA_PRIVATE_KEY;\nconst chainId = '501'; // Solana Mainnet\nconst rpcUrl = process.env.SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com';\n\n// Constants\nconst SOL_ADDRESS = '11111111111111111111111111111111'; // Native SOL\nconst USDC_ADDRESS = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'; // USDC\n\n// Initialize Solana connection\nconst connection = new Connection(rpcUrl, 'confirmed');\n\n// Type definitions\ninterface GasLimitApiResponse {\n    code: string;\n    msg?: string;\n    data: Array<{\n        gasLimit: string;\n    }>;\n}\n\ninterface SimulationApiResponse {\n    code: string;\n    msg?: string;\n    data: Array<{\n        intention: string;\n        gasUsed?: string;\n        failReason?: string;\n        assetChange?: Array<{\n            assetType: string;\n            name: string;\n            symbol: string;\n            decimals: number;\n            address: string;\n            imageUrl: string;\n            rawValue: string;\n        }>;\n        risks?: Array<any>;\n    }>;\n}\n\ninterface BroadcastApiResponse {\n    code: string;\n    msg?: string;\n    data: Array<{\n        orderId: string;\n    }>;\n}\n\ninterface TxErrorInfo {\n    error: string;\n    message: string;\n    action: string;\n}\n\n// ============================================================================\n// API Functions\n// ============================================================================\n\n/**\n * Get gas limit from 交易上链 API\n */\nasync function getGasLimit(\n    fromAddress: string,\n    toAddress: string,\n    txAmount: string = '0',\n    inputData: string = ''\n): Promise<string> {\n    try {\n        console.log('Getting gas limit from 交易上链 API...');\n\n        const path = 'dex/pre-transaction/gas-limit';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            chainIndex: chainId,\n            fromAddress: fromAddress,\n            toAddress: toAddress,\n            txAmount: txAmount,\n            extJson: {\n                inputData: inputData\n            }\n        };\n\n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post<GasLimitApiResponse>(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const gasLimit = response.data.data[0].gasLimit;\n            console.log(`Gas Limit obtained: ${gasLimit}`);\n            return gasLimit;\n        } else {\n            throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Failed to get gas limit:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Get swap data from OKX API\n */\nasync function getSwapData(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage = '0.5'\n) {\n    try {\n        console.log('Getting swap data from OKX API...');\n\n        const timestamp = new Date().toISOString();\n        const requestPath = \"/api/v5/dex/aggregator/swap\";\n        const queryString = \"?\" + new URLSearchParams({\n            chainIndex: chainId,\n            fromTokenAddress,\n            toTokenAddress,\n            amount,\n            slippage,\n            userWalletAddress: WALLET_ADDRESS!,\n            autoSlippage: \"false\",\n            maxAutoSlippageBps: \"0\"\n        }).toString();\n\n        const headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\n        const response = await fetch(`https://web3.okx.com${requestPath}${queryString}`, {\n            method: \"GET\",\n            headers\n        });\n\n        if (!response.ok) {\n            throw new Error(`Failed to get swap data: ${response.status} ${await response.text()}`);\n        }\n\n        const data = await response.json();\n        console.log('Swap data obtained');\n        return data.data[0]; // Return only the first swap data object\n    } catch (error) {\n        console.error('Failed to get swap data:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Simulate transaction using 交易上链 API\n */\nasync function simulateTransaction(swapData: any) {\n    try {\n        console.log('Simulating transaction with 交易上链 API...');\n        const path = 'dex/pre-transaction/simulate';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            chainIndex: chainId,\n            fromAddress: swapData.tx.from,\n            toAddress: swapData.tx.to,\n            txAmount: swapData.tx.value,\n            extJson: {\n                inputData: swapData.tx.data\n            }\n        };\n\n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post<SimulationApiResponse>(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const simulationData = response.data.data[0];\n            if (simulationData.failReason) {\n                throw new Error(`Simulation failed: ${simulationData.failReason}`);\n            }\n            console.log(`Transaction simulation successful. Gas used: ${simulationData.gasUsed}`);\n            console.log('Simulation API Response:', simulationData);\n            return simulationData;\n        } else {\n            throw new Error(`Simulation API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Transaction simulation failed:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Broadcast transaction using 交易上链 API with RPC fallback\n */\nasync function broadcastTransaction(\n    signedTx: string,\n    chainId: string,\n    walletAddress: string\n): Promise<string> {\n    try {\n        console.log('Broadcasting transaction via 交易上链 API...');\n        \n        const path = 'dex/pre-transaction/broadcast-transaction';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            signedTx: signedTx,\n            chainIndex: chainId,\n            address: walletAddress\n        };\n\n        console.log('Broadcast request body:', JSON.stringify(body, null, 2));\n\n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post<BroadcastApiResponse>(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const orderId = response.data.data[0].orderId;\n            console.log(`Transaction broadcast successful. Order ID: ${orderId}`);\n            return orderId;\n        } else {\n            throw new Error(`Broadcast API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('OKX API broadcast failed:', (error as Error).message);\n        \n        // Fallback to direct RPC broadcast\n        try {\n            console.log('Attempting direct RPC broadcast as fallback...');\n            \n            // Decode the signed transaction\n            const txBytes = bs58.decode(signedTx);\n            \n            // Send directly to Solana RPC\n            const signature = await connection.sendRawTransaction(txBytes, {\n                skipPreflight: false,\n                preflightCommitment: 'processed'\n            });\n            \n            console.log(`Direct RPC broadcast successful. Signature: ${signature}`);\n            \n            // Wait for confirmation\n            const confirmation = await connection.confirmTransaction(signature, 'confirmed');\n            \n            if (confirmation.value.err) {\n                throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);\n            }\n            \n            console.log(`Transaction confirmed: https://solscan.io/tx/${signature}`);\n            return signature;\n            \n        } catch (rpcError) {\n            console.error('RPC broadcast also failed:', (rpcError as Error).message);\n            throw new Error(`Both OKX API and RPC broadcast failed. OKX Error: ${(error as Error).message}, RPC Error: ${(rpcError as Error).message}`);\n        }\n    }\n}\n\n/**\n * Track transaction status using 交易上链 API\n */\nasync function trackTransaction(\n    orderId: string,\n    intervalMs: number = 5000,\n    timeoutMs: number = 180000 // Reduced timeout to 3 minutes\n): Promise<any> {\n    console.log(`Tracking transaction with Order ID: ${orderId}`);\n\n    const startTime = Date.now();\n    let lastStatus = '';\n    let pendingCount = 0;\n\n    while (Date.now() - startTime < timeoutMs) {\n        try {\n            const path = 'dex/post-transaction/orders';\n            const url = `https://web3.okx.com/api/v5/${path}`;\n\n            const params = {\n                orderId: orderId,\n                chainIndex: chainId,\n                address: WALLET_ADDRESS!,\n                limit: '1'\n            };\n\n            const timestamp = new Date().toISOString();\n            const requestPath = `/api/v5/${path}`;\n            const queryString = \"?\" + new URLSearchParams(params).toString();\n            const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n            const response = await axios.get(url, { params, headers });\n\n            const responseData = response.data as any;\n            if (responseData.code === '0' && responseData.data && responseData.data.length > 0) {\n                if (responseData.data[0].orders && responseData.data[0].orders.length > 0) {\n                    const txData = responseData.data[0].orders[0];\n                    const status = txData.txStatus;\n\n                    if (status !== lastStatus) {\n                        lastStatus = status;\n\n                        if (status === '1') {\n                            pendingCount++;\n                            console.log(`Transaction pending (${pendingCount}): ${txData.txHash || 'Hash not available yet'}`);\n                            \n                            // If pending too long without a hash, something is wrong\n                            if (pendingCount > 12 && !txData.txHash) { // 1 minute of pending without hash\n                                console.warn('Transaction has been pending for too long without a transaction hash. This may indicate an issue.');\n                            }\n                        } else if (status === '2') {\n                            console.log(`Transaction successful: https://web3.okx.com/explorer/solana/tx/${txData.txHash}`);\n                            return txData;\n                        } else if (status === '3') {\n                            const failReason = txData.failReason || 'Unknown reason';\n                            const errorMessage = `Transaction failed: ${failReason}`;\n\n                            console.error(errorMessage);\n\n                            const errorInfo = handleTransactionError(txData);\n                            console.log(`Error type: ${errorInfo.error}`);\n                            console.log(`Suggested action: ${errorInfo.action}`);\n\n                            throw new Error(errorMessage);\n                        }\n                    } else if (status === '1') {\n                        pendingCount++;\n                        // Show progress for long pending transactions\n                        if (pendingCount % 6 === 0) { // Every 30 seconds\n                            const elapsed = Math.round((Date.now() - startTime) / 1000);\n                            console.log(`Still pending... (${elapsed}s elapsed)`);\n                        }\n                    }\n                } else {\n                    console.log(`No orders found for Order ID: ${orderId}`);\n                }\n            } else {\n                console.log('No response data from tracking API');\n            }\n        } catch (error) {\n            console.warn('Error checking transaction status:', (error as Error).message);\n        }\n\n        await new Promise(resolve => setTimeout(resolve, intervalMs));\n    }\n\n    throw new Error(`Transaction tracking timed out after ${timeoutMs/1000} seconds. The transaction may still be processing.`);\n}\n\n// ============================================================================\n// Transaction Signing Functions\n// ============================================================================\n\n/**\n * Sign transaction with private key - Fixed OKX approach with gas limit analysis\n */\nasync function signTransaction(swapData: any, gasLimit: string): Promise<string> {\n    try {\n        console.log('Signing transaction...');\n        \n        if (!PRIVATE_KEY) {\n            throw new Error('Private key not found in environment variables');\n        }\n\n        // Create keypair from private key\n        const privateKeyBytes = bs58.decode(PRIVATE_KEY);\n        const keypair = Keypair.fromSecretKey(privateKeyBytes);\n        \n        if (!swapData.tx || !swapData.tx.data) {\n            throw new Error('No transaction data found in swap response');\n        }\n        \n        const callData = swapData.tx.data;\n        console.log('Transaction data length:', callData.length);\n        console.log('Gas limit from API:', gasLimit);\n        \n        try {\n            // Decode the base58 encoded transaction data (this is the correct approach)\n            const decodedTransaction = bs58.decode(callData);\n            console.log('Decoded transaction bytes length:', decodedTransaction.length);\n            \n            // Get the latest blockhash (CRITICAL!)\n            const recentBlockHash = await connection.getLatestBlockhash();\n            console.log('Got recent blockhash:', recentBlockHash.blockhash);\n            \n            let transaction: Transaction | VersionedTransaction;\n            \n            // Try VersionedTransaction first (more common for modern Solana programs)\n            try {\n                transaction = VersionedTransaction.deserialize(decodedTransaction);\n                console.log('Successfully deserialized as VersionedTransaction');\n                \n                // DEBUGGING: Let's see what instructions are already in the transaction\n                console.log('Number of instructions in OKX transaction:', transaction.message.compiledInstructions.length);\n                \n                // Check if there are already ComputeBudget instructions\n                const computeBudgetProgram = new PublicKey('ComputeBudget111111111111111111111111111111');\n                const computeBudgetIndex = transaction.message.staticAccountKeys.findIndex(\n                    key => key.equals(computeBudgetProgram)\n                );\n                \n                if (computeBudgetIndex !== -1) {\n                    console.log('ComputeBudget program found at index:', computeBudgetIndex);\n                    \n                    // Check which instructions use the ComputeBudget program\n                    const computeBudgetInstructions = transaction.message.compiledInstructions.filter(\n                        ix => ix.programIdIndex === computeBudgetIndex\n                    );\n                    console.log('Number of ComputeBudget instructions:', computeBudgetInstructions.length);\n                    \n                    // Analyze each ComputeBudget instruction\n                    computeBudgetInstructions.forEach((ix, i) => {\n                        const data = ix.data;\n                        if (data.length > 0) {\n                            const instructionType = data[0];\n                            console.log(`ComputeBudget instruction ${i}: type ${instructionType}`);\n                            if (instructionType === 0 && data.length >= 5) {\n                                // SetComputeUnitLimit instruction\n                                const computeUnits = new Uint32Array(data.slice(1, 5).buffer)[0];\n                                console.log(`  - Current compute unit limit: ${computeUnits}`);\n                                console.log(`  - Gas limit from API: ${gasLimit}`);\n                                \n                                // Check if we need to update it\n                                const apiGasLimit = parseInt(gasLimit);\n                                if (computeUnits !== apiGasLimit) {\n                                    console.log(`  - Compute units mismatch! OKX: ${computeUnits}, API: ${apiGasLimit}`);\n                                    // We could potentially update this here\n                                }\n                            } else if (instructionType === 1 && data.length >= 9) {\n                                // SetComputeUnitPrice instruction\n                                const microLamports = new BigUint64Array(data.slice(1, 9).buffer)[0];\n                                console.log(`  - Current compute unit price: ${microLamports} microlamports`);\n                            }\n                        }\n                    });\n                } else {\n                    console.log('No ComputeBudget program found - OKX transaction may not have compute budget instructions');\n                    console.log('We should add ComputeBudget instruction with gas limit:', gasLimit);\n                    \n                    // Add ComputeBudget instruction since OKX didn't include one\n                    const setComputeUnitLimitData = Buffer.alloc(5);\n                    setComputeUnitLimitData[0] = 0; // SetComputeUnitLimit instruction\n                    setComputeUnitLimitData.writeUInt32LE(parseInt(gasLimit), 1);\n                    \n                    // Add the ComputeBudget program to static accounts\n                    transaction.message.staticAccountKeys.push(computeBudgetProgram);\n                    const programIndex = transaction.message.staticAccountKeys.length - 1;\n                    \n                    // Add the compute budget instruction at the beginning\n                    transaction.message.compiledInstructions.unshift({\n                        programIdIndex: programIndex,\n                        accountKeyIndexes: [],\n                        data: setComputeUnitLimitData\n                    });\n                    \n                    console.log('Added ComputeBudget instruction with gas limit:', gasLimit);\n                }\n                \n                // CRITICAL: Update the blockhash in the transaction message\n                transaction.message.recentBlockhash = recentBlockHash.blockhash;\n                \n                // Sign the versioned transaction\n                transaction.sign([keypair]);\n                console.log('Signed VersionedTransaction');\n                \n            } catch (versionedError) {\n                console.log('VersionedTransaction failed, trying legacy Transaction');\n                \n                try {\n                    transaction = Transaction.from(decodedTransaction);\n                    console.log('Successfully deserialized as legacy Transaction');\n                    \n                    // DEBUGGING: Check legacy transaction instructions\n                    console.log('Number of instructions in legacy transaction:', transaction.instructions.length);\n                    \n                    // Check for ComputeBudget instructions in legacy format\n                    const computeBudgetProgram = new PublicKey('ComputeBudget111111111111111111111111111111');\n                    const computeBudgetInstructions = transaction.instructions.filter(\n                        ix => ix.programId.equals(computeBudgetProgram)\n                    );\n                    \n                    if (computeBudgetInstructions.length === 0) {\n                        console.log('No ComputeBudget instructions found in legacy transaction');\n                        console.log('Adding ComputeBudget instruction with gas limit:', gasLimit);\n                        \n                        // Add ComputeBudget instruction\n                        const setComputeUnitLimitData = Buffer.alloc(5);\n                        setComputeUnitLimitData[0] = 0; // SetComputeUnitLimit instruction\n                        setComputeUnitLimitData.writeUInt32LE(parseInt(gasLimit), 1);\n                        \n                        const computeBudgetIx = {\n                            programId: computeBudgetProgram,\n                            keys: [],\n                            data: setComputeUnitLimitData\n                        };\n                        \n                        // Add at the beginning\n                        transaction.instructions.unshift(computeBudgetIx);\n                        console.log('Added ComputeBudget instruction to legacy transaction');\n                    } else {\n                        console.log('Found existing ComputeBudget instructions:', computeBudgetInstructions.length);\n                    }\n                    \n                    // CRITICAL: Update the blockhash in the transaction\n                    transaction.recentBlockhash = recentBlockHash.blockhash;\n                    \n                    // Sign the legacy transaction\n                    transaction.sign(keypair);\n                    console.log('Signed legacy Transaction');\n                    \n                } catch (legacyError) {\n                    console.log('Both transaction types failed to deserialize');\n                    console.log('VersionedTransaction error:', (versionedError as Error).message);\n                    console.log('Legacy Transaction error:', (legacyError as Error).message);\n                    \n                    // This should not happen with proper OKX data\n                    throw new Error('Failed to deserialize OKX transaction data. Data may be corrupted.');\n                }\n            }\n\n            // Serialize and encode the signed transaction\n            const serializedTx = transaction.serialize();\n            const encodedTx = bs58.encode(serializedTx);\n            \n            console.log('Transaction signed and encoded successfully');\n            return encodedTx;\n            \n        } catch (error) {\n            console.log('Failed to process OKX transaction data:', (error as Error).message);\n            // If we reach here, the OKX data is not in expected format\n            throw new Error(`Cannot process OKX transaction data: ${(error as Error).message}`);\n        }\n        \n    } catch (error) {\n        console.error('Failed to sign transaction:', (error as Error).message);\n        throw error;\n    }\n}\n\n// ============================================================================\n// Error Handling\n// ============================================================================\n\n/**\n * Comprehensive error handling with failReason\n */\nfunction handleTransactionError(txData: any): TxErrorInfo {\n    const failReason = txData.failReason || 'Unknown reason';\n\n    console.error(`Transaction failed with reason: ${failReason}`);\n\n    return {\n        error: 'TRANSACTION_FAILED',\n        message: failReason,\n        action: 'Try again or contact support'\n    };\n}\n\n// ============================================================================\n// Main Execution Functions\n// ============================================================================\n\n/**\n * Execute swap with full transaction flow\n */\nasync function executeSwap(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.05'\n): Promise<string> {\n    try {\n        console.log('Starting swap execution...');\n\n        // Step 1: Get swap data\n        const swapData = await getSwapData(fromTokenAddress, toTokenAddress, amount, slippage);\n        console.log('Swap data obtained');\n\n        // Step 2: Simulate transaction\n        const simulationResult = await simulateTransaction(swapData);\n        console.log('Transaction simulation completed');\n        console.log('Simulation result', simulationResult.intention);\n\n        // Step 3: Get gas limit\n        const gasLimit = await getGasLimit(\n            swapData.tx.from,\n            swapData.tx.to,\n            swapData.tx.value || '0',\n            swapData.tx.data\n        );\n        console.log('Gas limit obtained');\n\n        // Step 4: Check account balance\n        if (!(swapData.tx && swapData.tx.data)) {\n            throw new Error('No valid transaction data found in swap API response (tx.data missing)');\n        }\n        \n        console.log('Checking account balance...');\n        const fromPubkey = new PublicKey(swapData.tx.from);\n        const balance = await connection.getBalance(fromPubkey);\n        console.log(`Account balance: ${balance / 1e9} SOL`);\n        \n        // Check if we have enough balance for the transaction\n        const requiredAmount = parseInt(swapData.tx.value || '0');\n        console.log(`Required amount: ${requiredAmount / 1e9} SOL`);\n        \n        if (balance < requiredAmount) {\n            throw new Error(`Insufficient balance. Required: ${requiredAmount / 1e9} SOL, Available: ${balance / 1e9} SOL`);\n        }\n\n        // Step 5: Sign the transaction with private key\n        console.log('Signing transaction with private key...');\n        const signedTx = await signTransaction(swapData, gasLimit);\n        console.log('Transaction signed successfully');\n\n        // Step 6: Broadcast transaction\n        console.log('Broadcasting signed transaction via 交易上链 API...');\n        const txHash = await broadcastTransaction(signedTx, chainId, WALLET_ADDRESS!);\n        console.log(`Transaction broadcast successful. Hash: ${txHash}`);\n\n        // Step 7: Track transaction\n        console.log('Tracking transaction status...');\n        const trackingResult = await trackTransaction(txHash);\n        console.log('Transaction tracking completed');\n        console.log('Tracking result', trackingResult);\n\n        return txHash;\n    } catch (error) {\n        console.error('Swap execution failed:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Execute swap with simulation and detailed logging\n */\nasync function executeSwapWithSimulation(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.05'\n): Promise<any> {\n    try {\n        console.log('Starting swap execution with simulation...');\n\n        const txHash = await executeSwap(fromTokenAddress, toTokenAddress, amount, slippage);\n\n        console.log('Swap execution completed successfully!');\n        console.log(`Transaction Hash: ${txHash}`);\n\n        return { success: true, txHash };\n    } catch (error) {\n        console.error('Swap execution failed:', (error as Error).message);\n        return { success: false, error: (error as Error).message };\n    }\n}\n\n/**\n * Simulation-only mode\n */\nasync function simulateOnly(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.05'\n): Promise<any> {\n    try {\n        console.log('Starting simulation-only mode...');\n        console.log(`Simulation Details:`);\n        console.log(`   From Token: ${fromTokenAddress}`);\n        console.log(`   To Token: ${toTokenAddress}`);\n        console.log(`   Amount: ${amount}`);\n        console.log(`   Slippage: ${slippage}%`);\n\n        // Step 1: Get swap data\n        const swapData = await getSwapData(fromTokenAddress, toTokenAddress, amount, slippage);\n        console.log('Swap data obtained');\n\n        // Step 2: Simulate transaction\n        const simulationResult = await simulateTransaction(swapData);\n        console.log('Transaction simulation completed');\n\n        // Step 3: Get gas limit\n        const gasLimit = await getGasLimit(\n            swapData.tx.from,\n            swapData.tx.to,\n            swapData.tx.value || '0',\n            swapData.tx.data\n        );\n        console.log('Gas limit obtained');\n\n        return {\n            success: true,\n            swapData,\n            simulationResult,\n            gasLimit,\n            estimatedGasUsed: simulationResult.gasUsed,\n        };\n    } catch (error) {\n        console.error('Simulation failed:', (error as Error).message);\n        return { success: false, error: (error as Error).message };\n    }\n}\n\n// ============================================================================\n// Main Entry Point\n// ============================================================================\n\nasync function main() {\n    try {\n        console.log('Solana Swap Tools with 交易上链 API');\n        console.log('=====================================');\n\n        // Validate environment variables\n        if (!WALLET_ADDRESS || !PRIVATE_KEY) {\n            throw new Error('Missing wallet address or private key in environment variables');\n        }\n\n        console.log(`Wallet Address: ${WALLET_ADDRESS}`);\n        console.log(`Chain ID: ${chainId}`);\n        console.log(`RPC URL: ${rpcUrl}`);\n\n        // Parse command line arguments\n        const args = process.argv.slice(2);\n        const mode = args[0] || 'simulate'; // Default to simulate mode\n\n        // Example parameters\n        const fromToken = SOL_ADDRESS;\n        const toToken = USDC_ADDRESS;\n        const amount = '10000000'; // 0.01 SOL in lamports\n        const slippage = '0.05'; // 0.5%\n\n        console.log('\\nConfiguration:');\n        console.log(`   From: ${fromToken} (SOL)`);\n        console.log(`   To: ${toToken} (USDC)`);\n        console.log(`   Amount: ${parseInt(amount) / 1e9} SOL`);\n        console.log(`   Slippage: ${slippage}%`);\n        console.log(`   Mode: ${mode}`);\n\n        let result;\n\n        switch (mode.toLowerCase()) {\n            case 'simulate':\n            case 'sim':\n                result = await simulateOnly(fromToken, toToken, amount, slippage);\n                break;\n            case 'execute':\n            case 'exec':\n                result = await executeSwapWithSimulation(fromToken, toToken, amount, slippage);\n                break;\n            default:\n                console.log('\\nAvailable modes:');\n                console.log('   simulate/sim  - Only simulate the transaction');\n                console.log('   execute/exec  - Execute the full swap');\n                console.log('\\nExample: npm run solana-swap simulate');\n                return;\n        }\n\n        if (result.success) {\n            console.log('\\nOperation completed successfully!');\n            if (mode === 'simulate' || mode === 'sim') {\n                console.log(`Gas Limit: ${result.gasLimit}`);\n            } else {\n                console.log(`Transaction Hash: ${result.txHash}`);\n            }\n        } else {\n            console.log('\\nOperation failed!');\n            console.log(`Error: ${result.error}`);\n        }\n    } catch (error) {\n        console.error('Main execution failed:', (error as Error).message);\n        process.exit(1);\n    }\n}\n\n// Run the script\nif (require.main === module) {\n    main();\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport {\n    executeSwap,\n    executeSwapWithSimulation,\n    simulateOnly,\n    getSwapData,\n    simulateTransaction,\n    getGasLimit,\n    broadcastTransaction,\n    trackTransaction,\n    signTransaction\n};\n```\n\nYou can run this script using `solana-swap-executor.ts sim` or `solana-swap-executor.ts exec`.\n\n`sim` simulates a transaction using swap data using the transaction simulation API and retruns `gasLimit` info `exec` executes a transaction using the broadcast API\n\n## 8\\. MEV保护[#](#8.-mev保护)\n\nSolana交易存在MEV（最大可提取价值）风险。虽然MEV保护不直接包含在SDK中，但您可以使用API优先的方法自行实施。\n\n第一道防线使用动态优先级费用-将其视为您在拍卖中对抗MEV机器人的出价。\n\n```typescript\n/**\n * Broadcast transaction with MEV protection enabled\n */\nasync function broadcastTransactionWithMEV(\n    signedTx: string,\n    chainId: string = \"501\",\n    walletAddress: string,\n    enableMevProtection: boolean = true\n): Promise<string> {\n    try {\n        console.log('Broadcasting transaction with MEV protection...');\n\n        const path = 'dex/pre-transaction/broadcast-transaction';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            signedTx: signedTx,\n            chainIndex: chainId,\n            address: walletAddress,\n            extraData: JSON.stringify({\n                enableMevProtection: enableMevProtection\n            })\n        };\n\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const orderId = response.data.data[0].orderId;\n            console.log(`Transaction broadcast with MEV protection. Order ID: ${orderId}`);\n            return orderId;\n        } else {\n            throw new Error(`Broadcast API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('MEV-protected broadcast failed:', error);\n        throw error;\n    }\n}\n```\n\n#### Jito Integration for Enhanced Protection[#](#jito-integration-for-enhanced-protection)\n\nFor additional MEV protection on Solana, you can include Jito-specific parameters:\n\n```typescript\n/**\n * Broadcast transaction with Jito MEV protection\n */\nasync function broadcastTransactionWithJito(\n    signedTx: string,\n    jitoSignedTx: string,\n    chainId: string = \"501\",\n    walletAddress: string\n): Promise<string> {\n    try {\n        console.log('Broadcasting transaction with Jito MEV protection...');\n\n        const path = 'dex/pre-transaction/broadcast-transaction';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            signedTx: signedTx,\n            chainIndex: chainId,\n            address: walletAddress,\n            extraData: JSON.stringify({\n                enableMevProtection: true,\n                jitoSignedTx: jitoSignedTx\n            })\n        };\n\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const orderId = response.data.data[0].orderId;\n            console.log(`Transaction broadcast with Jito protection. Order ID: ${orderId}`);\n            return orderId;\n        } else {\n            throw new Error(`Broadcast API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Jito-protected broadcast failed:', error);\n        throw error;\n    }\n}\n```\n\n#### Updated Broadcast Function with MEV Parameters[#](#updated-broadcast-function-with-mev-parameters)\n\nHere's the updated `broadcastTransaction` function that includes MEV protection parameters:\n\n```typescript\n/**\n * Enhanced broadcast transaction with MEV protection parameters\n */\nasync function broadcastTransaction(\n    signedTx: string,\n    chainId: string = \"501\",\n    walletAddress: string,\n    enableMevProtection: boolean = false,\n    jitoSignedTx: string = \"\"\n): Promise<string> {\n    try {\n        console.log(`Broadcasting transaction${enableMevProtection ? ' with MEV protection' : ''}...`);\n\n        const path = 'dex/pre-transaction/broadcast-transaction';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body: any = {\n            signedTx: signedTx,\n            chainIndex: chainId,\n            address: walletAddress\n        };\n\n        // Add MEV protection parameters if enabled\n        if (enableMevProtection || jitoSignedTx) {\n            const extraData: any = {};\n            \n            if (enableMevProtection) {\n                extraData.enableMevProtection = true;\n            }\n            \n            if (jitoSignedTx) {\n                extraData.jitoSignedTx = jitoSignedTx;\n            }\n            \n            body.extraData = JSON.stringify(extraData);\n        }\n\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const orderId = response.data.data[0].orderId;\n            console.log(`Transaction broadcast successful. Order ID: ${orderId}`);\n            return orderId;\n        } else {\n            throw new Error(`Broadcast API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Broadcast failed:', error);\n        throw error;\n    }\n}\n```\n\n#### Usage Examples[#](#usage-examples)\n\n**Basic swap without MEV protection:**\n\n```typescript\n// Standard broadcast (no MEV protection)\nconst orderId = await broadcastTransaction(signedTx, \"501\", walletAddress);\n```\n\n**Swap with MEV protection enabled:**\n\n```typescript\n// With MEV protection\nconst orderId = await broadcastTransaction(signedTx, \"501\", walletAddress, true);\n```\n\n**Swap with Jito MEV protection:**\n\n```typescript\n// With Jito protection\nconst orderId = await broadcastTransaction(signedTx, \"501\", walletAddress, true, jitoSignedTransaction);\n```\n\n**Swap with only Jito (no general MEV protection):**\n\n```typescript\n// Only Jito protection\nconst orderId = await broadcastTransaction(signedTx, \"501\", walletAddress, false, jitoSignedTransaction);\n```\n\n#### Integration with Complete Swap Flow[#](#integration-with-complete-swap-flow)\n\nHere's how to integrate MEV protection into your complete swap execution:\n\n```typescript\n/**\n * Execute swap with MEV protection\n */\nasync function executeSwapWithMEVProtection(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.005',\n    enableMevProtection: boolean = true\n): Promise<string> {\n    try {\n        // Step 1: Get swap data\n        const swapData = await getSwapData(fromTokenAddress, toTokenAddress, amount, slippage);\n        \n        // Step 2: Prepare and sign transaction\n        const { transaction } = await prepareTransaction(swapData.tx.data);\n        const signedTx = await signTransaction(transaction);\n        \n        // Step 3: Broadcast with MEV protection\n        const orderId = await broadcastTransaction(signedTx, \"501\", userAddress, enableMevProtection);\n        \n        // Step 4: Track transaction\n        const result = await trackTransaction(orderId);\n        \n        return result.txHash;\n    } catch (error) {\n        console.error(\"MEV-protected swap failed:\", error);\n        throw error;\n    }\n}\n```\n\nMEV 保护功能与您现有的 EVM 和 Solana 交换实现无缝集成，并为 Solana、Base、以太坊和 BSC 提供额外的安全保护，以抵御 MEV 攻击。\n\n## 方法2：SDK方法[#](#方法2：sdk方法)\n\n使用OKX DEX SDK提供了更简单的开发人员体验，同时保留了API方法的所有功能。SDK为您处理许多实现细节，包括重试逻辑、错误处理和事务管理。\n\n## 1.安装SDK[#](#1.安装sdk)\n\n```typescript\nnpm install @okx-dex/okx-dex-sdk\n# or\nyarn add @okx-dex/okx-dex-sdk\n# or\npnpm add @okx-dex/okx-dex-sdk\n```\n\n## 2.设置环境[#](#2.设置环境)\n\n使用您的API凭据和钱包信息创建一个. env文件：\n\n```typescript\n# OKX API Credentials\nOKX_API_KEY=your_api_key\nOKX_SECRET_KEY=your_secret_key\nOKX_API_PASSPHRASE=your_passphrase\nOKX_PROJECT_ID=your_project_id\n# Solana Configuration\nSOLANA_RPC_URL=your_solana_rpc_url\nSOLANA_WALLET_ADDRESS=your_solana_wallet_address\nSOLANA_PRIVATE_KEY=your_solana_private_key\n# Ethereum Configuration\nEVM_RPC_URL=your_evm_rpc_url\nEVM_WALLET_ADDRESS=your_evm_wallet_address\nEVM_PRIVATE_KEY=your_evm_private_key\n```\n\n## 3.初始化客户端[#](#3.初始化客户端)\n\n为您的DEX客户端创建一个文件（例如，DexClient. ts）：\n\n```typescript\nimport { OKXDexClient } from '@okx-dex/okx-dex-sdk';\nimport { createEVMWallet } from '@okx-dex/okx-dex-sdk/core/evm-wallet';\nimport { createWallet } from '@okx-dex/okx-dex-sdk/core/wallet';\nimport { Connection } from '@solana/web3.js';\nimport { ethers } from 'ethers';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\n// EVM setup (Ethereum, Base, Arbitrum, etc.)\nconst evmProvider = new ethers.JsonRpcProvider(process.env.EVM_RPC_URL!);\nconst evmWallet = createEVMWallet(process.env.EVM_PRIVATE_KEY!, evmProvider);\n\n// Solana setup\nconst solanaConnection = new Connection(process.env.SOLANA_RPC_URL!);\nconst solanaWallet = createWallet(process.env.SOLANA_PRIVATE_KEY!, solanaConnection);\n\n// Initialize the client\nconst client = new OKXDexClient({\n    // API credentials (get from OKX Developer Portal)\n    apiKey: process.env.OKX_API_KEY!,\n    secretKey: process.env.OKX_SECRET_KEY!,\n    apiPassphrase: process.env.OKX_API_PASSPHRASE!,\n    projectId: process.env.OKX_PROJECT_ID!,\n    \n    // EVM configuration (works for all EVM chains)\n    evm: {\n        wallet: evmWallet\n    },\n    \n    // Solana configuration\n    solana: {\n        wallet: solanaWallet,\n        computeUnits: 300000, // Optional\n        maxRetries: 3 // Optional\n    },\n})\n```\n\n## 4.调用SDK执行兑换[#](#4.调用sdk执行兑换)\n\n创建兑换执行的文件：\n\n```typescript\n// swap.ts\nimport { client } from './DexClient';\n/**\n * Example: Execute a swap from SOL to USDC\n */\nasync function executeSwap() {\n  try {\n    if (!process.env.SOLANA_PRIVATE_KEY) {\n      throw new Error('Missing SOLANA_PRIVATE_KEY in .env file');\n    }\n    // Get quote to fetch token information\n    console.log(\"Getting token information...\");\n    const quote = await client.dex.getQuote({\n        chainId: '501',\n        fromTokenAddress: '11111111111111111111111111111111', // SOL\n        toTokenAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n        amount: '1000000', // Small amount for quote\n        slippage: '0.005' // 0.5% slippage\n    });\n    const tokenInfo = {\n        fromToken: {\n            symbol: quote.data[0].fromToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].fromToken.decimal),\n            price: quote.data[0].fromToken.tokenUnitPrice\n        },\n        toToken: {\n            symbol: quote.data[0].toToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].toToken.decimal),\n            price: quote.data[0].toToken.tokenUnitPrice\n        }\n    };\n    // Convert amount to base units (for display purposes)\n    const humanReadableAmount = 0.1; // 0.1 SOL\n    const rawAmount = (humanReadableAmount * Math.pow(10, tokenInfo.fromToken.decimals)).toString();\n    console.log(\"\\nSwap Details:\");\n    console.log(\"--------------------\");\n    console.log(`From: ${tokenInfo.fromToken.symbol}`);\n    console.log(`To: ${tokenInfo.toToken.symbol}`);\n    console.log(`Amount: ${humanReadableAmount} ${tokenInfo.fromToken.symbol}`);\n    console.log(`Amount in base units: ${rawAmount}`);\n    console.log(`Approximate USD value: $${(humanReadableAmount * parseFloat(tokenInfo.fromToken.price)).toFixed(2)}`);\n    // Execute the swap\n    console.log(\"\\nExecuting swap...\");\n    const swapResult = await client.dex.executeSwap({\n      chainId: '501', // Solana chain ID\n      fromTokenAddress: '11111111111111111111111111111111', // SOL\n      toTokenAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n      amount: rawAmount,\n      slippage: '0.005', // 0.5% slippage\n      userWalletAddress: process.env.SOLANA_WALLET_ADDRESS!\n    });\n    console.log('Swap executed successfully:');\n    console.log(JSON.stringify(swapResult, null, 2));\n\n    return swapResult;\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error('Error executing swap:', error.message);\n      // API errors include details in the message\n      if (error.message.includes('API Error:')) {\n        const match = error.message.match(/API Error: (.*)/);\n        if (match) console.error('API Error Details:', match[1]);\n      }\n    }\n    throw error;\n  }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n  executeSwap()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Error:', error);\n      process.exit(1);\n    });\n}\nexport { executeSwap };\n```\n\n## 5.附加SDK功能[#](#5.附加sdk功能)\n\nSDK提供了简化开发的附加方法： 获取代币对的报价\n\n```typescript\nconst quote = await client.dex.getQuote({\n    chainId: '501',  // Solana\n    fromTokenAddress: '11111111111111111111111111111111', // SOL\n    toTokenAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n    amount: '100000000',  // 0.1 SOL (in lamports)\n    slippage: '0.005'     // 0.5% slippage\n});\n```\n\n[\n\n交易 API\n\n](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)[\n\n在 Solana 链上兑换的高级用法\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-solana-advance-control)\n\n目录\n\n[方法1：API方法](#方法1：api方法)[1.设置环境](#1.设置环境)[2.获取兑换数据](#2.获取兑换数据)[3.准备交易](#3.准备交易)[4\\. 模拟交易](#4.-模拟交易)[5\\. 广播交易](#5.-广播交易)[6.追踪交易](#6.追踪交易)[7.完整实现](#7.完整实现)[8\\. MEV保护](#8.-mev保护)[方法2：SDK方法](#方法2：sdk方法)[1.安装SDK](#1.安装sdk)[2.设置环境](#2.设置环境)[3.初始化客户端](#3.初始化客户端)[4.调用SDK执行兑换](#4.调用sdk执行兑换)[5.附加SDK功能](#5.附加sdk功能)"
    },
    "在 Solana 链上兑换的高级用法#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n指南\n\n在 Solana 链上兑换的高级用法\n\n# 在 Solana 链上兑换的高级用法[#](#在-solana-链上兑换的高级用法)\n\n当你需要对兑换过程进行更多控制和组装定制时，可使用 swap-instruction 接口。 已有的 /swap 兑换接口的作用是，直接返回了构建好的交易数据，可直接签名执行。但 swap-instruction 兑换指令接口允许你：\n\n*   构建自定义的交易签名流程\n*   按照你的需要处理指令\n*   在已构建的交易添加自己的指令\n*   直接使用查找表来优化交易数据大小\n\n本指南将逐步介绍，如何使用兑换指令接口发起一笔完整的兑换交易。 你将了解如何从 API 接口中获取指令、组装处理它们并将其构建成一个可用的交易。\n\n## 1\\. 设置环境[#](#1.-设置环境)\n\n导入必要的库并配置 你的环境：\n\n```typescript\n// 与 DEX 交互所需的 Solana 依赖项\nimport {\n    Connection,          // 处理与 Solana 网络的 RPC 连接\n    Keypair,            // 管理用于签名的钱包密钥对\n    PublicKey,          // 处理 Solana 公钥的转换和验证\n    TransactionInstruction,    // 核心交易指令类型\n    TransactionMessage,        // 构建交易消息（v0 格式）\n    VersionedTransaction,      // 支持带有查找表的新交易格式\n    RpcResponseAndContext,     // RPC 响应包装类型\n    SimulatedTransactionResponse,  // 模拟结果类型\n    AddressLookupTableAccount,     // 用于交易大小优化\n    PublicKeyInitData              // 公钥输入类型\n} from \"@solana/web3.js\";\nimport base58 from \"bs58\";    // 用于私钥解码\nimport dotenv from \"dotenv\";  // 环境变量管理\ndotenv.config();\n```\n\n## 2\\. 初始化连接和钱包[#](#2.-初始化连接和钱包)\n\n设置 你的连接和钱包实例：\n\n```typescript\n// 注意：在生产环境中，请考虑使用具有高速率限制的可靠 RPC 端点\nconst connection = new Connection(\n    process.env.SOLANA_RPC_URL || \"https://api.mainnet-beta.solana.com\"\n);\n\n// 初始化用于签名的钱包\n// 该钱包将作为费用支付者和交易签名者\n// 确保它有足够的 SOL 来支付交易费用\nconst wallet = Keypair.fromSecretKey(\n    Uint8Array.from(base58.decode(process.env.PRIVATE_KEY?.toString() || \"\"))\n);\n```\n\n## 3\\. 配置兑换参数[#](#3.-配置兑换参数)\n\n设置 你的兑换参数：\n\n```typescript\n// 配置交换参数\n    const baseUrl = \"https://beta.okex.org/api/v5/dex/aggregator/swap-instruction\";\n    const params = {\n        chainId: \"501\",              // Solana 主网链 ID\n        feePercent: \"1\",            // 你计划收取的分佣费用百分比\n        amount: \"1000000\",          // 最小单位金额（例如，SOL 的 lamports）\n        fromTokenAddress: \"11111111111111111111111111111111\",  // SOL 铸币地址\n        toTokenAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",  // USDC 铸币地址\n        slippage: \"0.1\",            // 滑点容忍度 10%\n        userWalletAddress: process.env.WALLET_ADDRESS || \"\",   // 执行交换的钱包\n        priceTolerance: \"0\",        // 允许的最大价格影响\n        autoSlippage: \"false\",      // 使用固定滑点而非自动滑点\n        fromTokenReferrerWalletAddress: process.env.WALLET_ADDRESS || \"\",  // 用于推荐费用\n        pathNum: \"3\"                 // 考虑的最大路由数\n    }\n```\n\n## 4\\. 处理兑换指令[#](#4.-处理兑换指令)\n\n获取并处理兑换指令：\n\n```typescript\n// 将 DEX API 指令转换为 Solana 格式的辅助函数\n// DEX 返回的指令是自定义格式，需要转换\nfunction createTransactionInstruction(instruction: any): TransactionInstruction {\n    return new TransactionInstruction({\n        programId: new PublicKey(instruction.programId),  //  DEX 程序 ID\n        keys: instruction.accounts.map((key: any) => ({            pubkey: new PublicKey(key.pubkey),    // Account address\n            isSigner: key.isSigner,     // 如果账户必须签名则为 true\n            isWritable: key.isWritable  // 如果指令涉及到修改账户则为 true\n        })),\n        data: Buffer.from(instruction.data, 'base64')  // 指令参数\n    });\n}\n\n// 从 DEX 获取最佳交换路由和指令\n// 此调用会找到不同 DEX 流动性池中的最佳价格\nconst url = `${baseUrl}?${new URLSearchParams(params).toString()}`;\nconst { data: { instructionLists, addressLookupTableAccount } } =\n    await fetch(url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n    }).then(res => res.json());\n\n// 将 DEX 指令处理为 Solana 兼容格式\nconst instructions: TransactionInstruction[] = [];\n// 移除 DEX 返回的重复查找表地址\nconst addressLookupTableAccount2 = Array.from(new Set(addressLookupTableAccount));\nconsole.log(\"要加载的查找表:\", addressLookupTableAccount2);\n\n// 将每个 DEX 指令转换为 Solana 格式\nif (instructionLists?.length) {\n    instructions.push(...instructionLists.map(createTransactionInstruction));\n}\n```\n\n## 5\\. 处理地址查找表[#](#5.-处理地址查找表)\n\n使用地址查找表优化交易数据优化大小\n\n```typescript\n// 使用查找表以优化交易数据大小\n// 查找表对于与许多账户交互的复杂兑换至关重要\n// 它们显著减少了交易大小和成本\nconst addressLookupTableAccounts: AddressLookupTableAccount[] = [];\nif (addressLookupTableAccount2?.length > 0) {\n    console.log(\"加载地址查找表...\");\n     // 并行获取所有查找表以提高性能\n    const lookupTableAccounts = await Promise.all(\n        addressLookupTableAccount2.map(async (address: unknown) => {\n            const pubkey = new PublicKey(address as PublicKeyInitData);\n            // 从 Solana 获取查找表账户数据\n            const account = await connection\n                .getAddressLookupTable(pubkey)\n                .then((res) => res.value);\n            if (!account) {\n                throw new Error(`无法获取查找表账户 ${address}`);\n            }\n            return account;\n        })\n    );\n    addressLookupTableAccounts.push(...lookupTableAccounts);\n}\n```\n\n## 6\\. 创建并签名交易[#](#6.-创建并签名交易)\n\n创建交易消息并签名:\n\n```typescript\n// 获取最近的 blockhash 以确定交易时间和唯一性\n// 交易在此 blockhash 之后的有限时间内有效\nconst latestBlockhash = await connection.getLatestBlockhash('finalized');\n\n// 创建版本化交易消息\n// V0 消息格式需要支持查找表\nconst messageV0 = new TransactionMessage({\n    payerKey: wallet.publicKey,     // 费用支付者地址\n    recentBlockhash: latestBlockhash.blockhash,  // 交易时间\n    instructions                     // 来自 DEX 的兑换指令\n}).compileToV0Message(addressLookupTableAccounts);  // 包含查找表\n\n// 创建带有优化的新版本化交易\nconst transaction = new VersionedTransaction(messageV0);\n\n// 模拟交易以检查错误\n// 这有助于在支付费用之前发现问题\nconst result: RpcResponseAndContext<SimulatedTransactionResponse> =\n    await connection.simulateTransaction(transaction);\n\n// 使用费用支付者钱包签名交易\nconst feePayer = Keypair.fromSecretKey(\n    base58.decode(process.env.PRIVATE_KEY?.toString() || \"\")\n);\ntransaction.sign([feePayer])\n```\n\n## 7\\. 执行交易[#](#7.-执行交易)\n\n最后，模拟并发送交易：\n\n```typescript\n// 将交易发送到 Solana\n// skipPreflight=false 确保额外的验证\n// maxRetries 帮助处理网络问题\nconst txId = await connection.sendRawTransaction(transaction.serialize(), {\n    skipPreflight: false,  // 运行预验证\n    maxRetries: 5         // 失败时重试\n});\n\n// 记录交易详情\nconsole.log(\"Raw transaction:\", transaction.serialize());\nconsole.log(\"Base58 transaction:\", base58.encode(transaction.serialize()));\n\n// 记录模拟结果以供调试\nconsole.log(\"=========模拟结果=========\");\nresult.value.logs?.forEach((log) => {\n    console.log(log);\n});\n\n// 记录交易结果\nconsole.log(\"Transaction ID:\", txId);\nconsole.log(\"Explorer URL:\", `https://solscan.io/tx/${txId}`);\n```\n\n## 最佳实践和注意事项[#](#最佳实践和注意事项)\n\n在实施交换指令时，请记住以下关键点：\n\n*   错误处理：始终为API响应和事务模拟结果实现正确的错误处理。\n*   防滑保护：根据 你的用例和市场条件选择适当的防滑参数。\n*   Gas优化：在可用时使用地址查找表来减少事务大小和成本。\n*   事务模拟：在发送事务之前始终模拟事务，以便及早发现潜在问题。\n*   重试逻辑：使用适当的退避策略为失败的事务实现适当的重试机制。\n\n[\n\n在 Solana 链上搭建兑换应用\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-solana-quick-start)[\n\n在 EVM 链上搭建兑换应用\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-quick-start)\n\n目录\n\n[1\\. 设置环境](#1.-设置环境)[2\\. 初始化连接和钱包](#2.-初始化连接和钱包)[3\\. 配置兑换参数](#3.-配置兑换参数)[4\\. 处理兑换指令](#4.-处理兑换指令)[5\\. 处理地址查找表](#5.-处理地址查找表)[6\\. 创建并签名交易](#6.-创建并签名交易)[7\\. 执行交易](#7.-执行交易)[最佳实践和注意事项](#最佳实践和注意事项)"
    },
    "在 EVM 链上搭建兑换应用#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n指南\n\n在 EVM 链上搭建兑换应用\n\n# 在 EVM 链上搭建兑换应用[#](#在-evm-链上搭建兑换应用)\n\n在EVM网络上使用OKX DEX构建兑换应用程序有两种方法：\n\n1.  API 方法-直接调用 OKX DEX API\n2.  SDK 方法-使用 `@okx-dex/okx-dex-sdk` 简化开发人员体验\n\n本指南涵盖了这两种方法，以帮助您选择最适合您需求的方法。\n\n## 方法1：API方法[#](#方法1：api方法)\n\n在这种方法中，我们将直接使用OKX DEX API演示代币兑换。我们将在以太坊网络上将USDC兑换为ETH。\n\n## 1.设置环境[#](#1.设置环境)\n\n```typescript\n// --------------------- npm package ---------------------\nimport { Web3 } from 'web3';\nimport axios from 'axios';\nimport * as dotenv from 'dotenv';\nimport CryptoJS from 'crypto-js';\n// The URL for the Ethereum node you want to connect to\nconst web3 = new Web3('https://......com');\n// --------------------- environment variable ---------------------\n\n// Load hidden environment variables\ndotenv.config();\n\n// Your wallet information - REPLACE WITH YOUR OWN VALUES\nconst WALLET_ADDRESS: string = process.env.EVM_WALLET_ADDRESS || '0xYourWalletAddress';\nconst PRIVATE_KEY: string = process.env.EVM_PRIVATE_KEY || 'YourPrivateKey'; \n\n// Token addresses for swap on Base Chain\nconst ETH_ADDRESS: string = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'; // Native ETH\nconst USDC_ADDRESS: string = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'; // USDC on Base\n\n// Chain ID for Base Chain\nconst chainId: string = '8453';\n\n// API URL\nconst baseUrl: string = 'https://web3.okx.com/api/v5/';\n\n// Amount to swap in smallest unit (0.0005 ETH)\nconst SWAP_AMOUNT: string = '500000000000000'; // 0.0005 ETH\nconst SLIPPAGE: string = '0.005'; // 0.5% slippage tolerance\n\n// --------------------- util function ---------------------\nexport function getHeaders(timestamp: string, method: string, requestPath: string, queryString = \"\") {\n// Check https://web3.okx.com/zh-hans/web3/build/docs/waas/rest-authentication for api-key\n    const apiKey = process.env.OKX_API_KEY;\n    const secretKey = process.env.OKX_SECRET_KEY;\n    const apiPassphrase = process.env.OKX_API_PASSPHRASE;\n    const projectId = process.env.OKX_PROJECT_ID;\n\n    if (!apiKey || !secretKey || !apiPassphrase || !projectId) {\n        throw new Error(\"Missing required environment variables\");\n    }\n\n    const stringToSign = timestamp + method + requestPath + queryString;\n    return {\n        \"Content-Type\": \"application/json\",\n        \"OK-ACCESS-KEY\": apiKey,\n        \"OK-ACCESS-SIGN\": CryptoJS.enc.Base64.stringify(\n            CryptoJS.HmacSHA256(stringToSign, secretKey)\n        ),\n        \"OK-ACCESS-TIMESTAMP\": timestamp,\n        \"OK-ACCESS-PASSPHRASE\": apiPassphrase,\n        \"OK-ACCESS-PROJECT\": projectId,\n    };\n};\n```\n\n## 2.检查授权额度[#](#2.检查授权额度)\n\n您需要检查代币是否已批准DEX进行支出。此步骤仅适用于ERC20代币，而不是像ETH这样的本地代币。\n\n```typescript\n/**\n * Check token allowance for DEX\n * @param tokenAddress - Token contract address\n * @param ownerAddress - Your wallet address\n * @param spenderAddress - DEX spender address\n * @returns Allowance amount\n */\nasync function checkAllowance(\n  tokenAddress: string,\n  ownerAddress: string,\n  spenderAddress: string\n): Promise<bigint> {\n  const tokenABI = [\n    {\n      \"constant\": true,\n      \"inputs\": [\n        { \"name\": \"_owner\", \"type\": \"address\" },\n        { \"name\": \"_spender\", \"type\": \"address\" }\n      ],\n      \"name\": \"allowance\",\n      \"outputs\": [{ \"name\": \"\", \"type\": \"uint256\" }],\n      \"payable\": false,\n      \"stateMutability\": \"view\",\n      \"type\": \"function\"\n    }\n  ];\n\n  const tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);\n  try {\n    const allowance = await tokenContract.methods.allowance(ownerAddress, spenderAddress).call();\n    return BigInt(String(allowance));\n  } catch (error) {\n    console.error('Failed to query allowance:', error);\n    throw error;\n  }\n}\n```\n\n## 3.检查授权交易参数并发起授权[#](#3.检查授权交易参数并发起授权)\n\n由于 allowanceAmount 小于 fromTokenAmount，你需要对该币种进行授权。\n\n3.1 定义授权交易参数\n\n```typescript\nconst getApproveTransactionParams = {\n  chainId: chainId,\n  tokenContractAddress: tokenAddress,\n  approveAmount: amount\n};\n```\n\n3.2 定义辅助函数\n\n```typescript\nasync function getApproveTransaction(\n  tokenAddress: string,\n  amount: string\n): Promise<any> {\n  try {\n    const path = 'dex/aggregator/approve-transaction';\n    const url = `${baseUrl}${path}`;\n    const params = {\n      chainId: chainId,\n      tokenContractAddress: tokenAddress,\n      approveAmount: amount\n    };\n\n    // Prepare authentication\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n    const response = await axios.get(url, { params, headers });\n\n    if (response.data.code === '0') {\n      return response.data.data[0];\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to get approval transaction data:', (error as Error).message);\n    throw error;\n  }\n}\n```\n\n3.3 计算 gasLimit\n\n```typescript\n/**\n * Get transaction gas limit from Onchain gateway API\n * @param fromAddress - Sender address\n * @param toAddress - Target contract address\n * @param txAmount - Transaction amount (0 for approvals)\n * @param inputData - Transaction calldata\n * @returns Estimated gas limit\n */\nasync function getGasLimit(\n  fromAddress: string,\n  toAddress: string,\n  txAmount: string = '0',\n  inputData: string = ''\n): Promise<string> {\n  try {\n    const path = 'dex/pre-transaction/gas-limit';\n    const url = `https://web3.okx.com/api/v5/${path}`;\n\n    const body = {\n      chainIndex: chainId,\n      fromAddress: fromAddress,\n      toAddress: toAddress,\n      txAmount: txAmount,\n      extJson: {\n        inputData: inputData\n      }\n    };\n\n    // Prepare authentication with body included in signature\n    const bodyString = JSON.stringify(body);\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n    const response = await axios.post(url, body, { headers });\n\n    if (response.data.code === '0') {\n      return response.data.data[0].gasLimit;\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to get gas limit:', (error as Error).message);\n    throw error;\n  }\n}\n```\n\nUsing RPC to get the gas limit.\n\n```typescript\nconst gasLimit = await web3.eth.estimateGas({\n  from: WALLET_ADDRESS,\n  to: tokenAddress,\n  value: '0',\n  data: approveData.data\n});\n\n// Add 20% buffer\nconst gasLimit = (BigInt(gasLimit) * BigInt(12) / BigInt(10)).toString();\n```\n\n3.4 获取授权交易 tx 并且发送授权请求\n\n```typescript\n/**\n * Sign and send approve transaction\n * @param tokenAddress - Token to approve\n * @param amount - Amount to approve\n * @returns Transaction hash of the approval transaction\n */\nasync function approveToken(tokenAddress: string, amount: string): Promise<string | null> {\n  const spenderAddress = '0x3b3ae790Df4F312e745D270119c6052904FB6790'; // Ethereum Mainnet DEX spender\n  // See Router addresses at:  https://web3.okx.com/build/docs/waas/dex-smart-contract\n  const currentAllowance = await checkAllowance(tokenAddress, WALLET_ADDRESS, spenderAddress);\n\n  if (currentAllowance >= BigInt(amount)) {\n    console.log('Sufficient allowance already exists');\n    return null;\n  }\n\n  console.log('Insufficient allowance, approving tokens...');\n\n  // Get approve transaction data from OKX DEX API\n  const approveData = await getApproveTransaction(tokenAddress, amount);\n\n  // Get accurate gas limit using RPC\n  const gasLimit = await web3.eth.estimateGas({\n    from: WALLET_ADDRESS,\n    to: tokenAddress,\n    value: '0',\n    data: approveData.data\n  });\n  // Get accurate gas limit using Onchain gateway API\n//   const gasLimit = await getGasLimit(WALLET_ADDRESS, tokenAddress, '0', approveData.data);\n\n  // Get current gas price\n  const gasPrice = await web3.eth.getGasPrice();\n  const adjustedGasPrice = BigInt(gasPrice) * BigInt(15) / BigInt(10); // 1.5x for faster confirmation\n\n  // Get current nonce\n  const nonce = await web3.eth.getTransactionCount(WALLET_ADDRESS, 'latest');\n\n  // Create transaction object\n  const txObject = {\n    from: WALLET_ADDRESS,\n    to: tokenAddress,\n    data: approveData.data,\n    value: '0',\n    gas: gasLimit,\n    gasPrice: adjustedGasPrice.toString(),\n    nonce: nonce\n  };\n\n  // Sign and broadcast transaction\n  const signedTx = await web3.eth.accounts.signTransaction(txObject, PRIVATE_KEY);\n  const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  \n  console.log(`Approval transaction successful: ${receipt.transactionHash}`);\n  return receipt.transactionHash;\n}\n```\n\n## 4.请求询价接口，拿到询价数据[#](#4.请求询价接口，拿到询价数据)\n\n4.1定义报价参数\n\n```typescript\nconst quoteParams = {\n  amount: fromAmount,\n  chainId: chainId,\n  toTokenAddress: toTokenAddress,\n  fromTokenAddress: fromTokenAddress,\n};\n```\n\n4.2 定义辅助函数\n\n```typescript\n/**\n * Get swap quote from DEX API\n * @param fromTokenAddress - Source token address\n * @param toTokenAddress - Destination token address\n * @param amount - Amount to swap\n * @param slippage - Maximum slippage (e.g., \"0.005\" for 0.5%)\n * @returns Swap quote\n */\nasync function getSwapQuote(\n  fromTokenAddress: string,\n  toTokenAddress: string,\n  amount: string,\n  slippage: string = '0.005'\n): Promise<any> {\n  try {\n    const path = 'dex/aggregator/quote';\n    const url = `${baseUrl}${path}`;\n\n    const params = {\n      chainId: chainId,\n      fromTokenAddress,\n      toTokenAddress,\n      amount,\n      slippage\n    };\n\n    // Prepare authentication\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n    const response = await axios.get(url, { params, headers });\n\n    if (response.data.code === '0') {\n      return response.data.data[0];\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to get swap quote:', (error as Error).message);\n    throw error;\n  }\n}\n```\n\n## 5.请求兑换接口，发起交易[#](#5.请求兑换接口，发起交易)\n\n5.1 定义兑换参数\n\n```typescript\nconst swapParams = {\n      chainId: chainId,\n      fromTokenAddress,\n      toTokenAddress,\n      amount,\n      userWalletAddress: userAddress,\n      slippage\n};\n```\n\n5.2 定义辅助函数\n\n```typescript\n/**\n * Get swap transaction data from DEX API\n * @param fromTokenAddress - Source token address\n * @param toTokenAddress - Destination token address\n * @param amount - Amount to swap\n * @param userAddress - User wallet address\n * @param slippage - Maximum slippage (e.g., \"0.005\" for 0.5%)\n * @returns Swap transaction data\n */\nasync function getSwapTransaction(\n  fromTokenAddress: string,\n  toTokenAddress: string,\n  amount: string,\n  userAddress: string,\n  slippage: string = '0.005'\n): Promise<any> {\n  try {\n    const path = 'dex/aggregator/swap';\n    const url = `${baseUrl}${path}`;\n\n    const params = {\n      chainId: chainId,\n      fromTokenAddress,\n      toTokenAddress,\n      amount,\n      userWalletAddress: userAddress,\n      slippage\n    };\n\n    // Prepare authentication\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n    const response = await axios.get(url, { params, headers });\n\n    if (response.data.code === '0') {\n      return response.data.data[0];\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to get swap transaction data:', (error as Error).message);\n    throw error;\n  }\n}\n```\n\n## 6\\. 模拟交易[#](#6.-模拟交易)\n\n在执行实际兑换之前，务必模拟交易以确保其成功并识别任何潜在问题：\n\n此功能使用 `交易上链 API`。此 API 仅供我们的白名单客户使用。如您感兴趣，请联系我们 [dexapi@okx.com](mailto:dexapi@okx.com)。\n\n```typescript\nasync function simulateTransaction(swapData: any) {\n    try {\n        if (!swapData.tx) {\n            throw new Error('Invalid swap data format - missing transaction data');\n        }\n\n        const tx = swapData.tx;\n        const params: any = {\n            fromAddress: tx.from,\n            toAddress: tx.to,\n            txAmount: tx.value || '0',\n            chainIndex: chainId,\n            extJson: {\n                inputData: tx.data\n            },\n            includeDebug: true\n        };\n\n        const timestamp = new Date().toISOString();\n        const requestPath = \"/api/v5/dex/pre-transaction/simulate\";\n        const requestBody = JSON.stringify(params);\n        const headers = getHeaders(timestamp, \"POST\", requestPath, \"\", requestBody);\n\n        console.log('Simulating transaction...');\n        const response = await axios.post(\n            `https://web3.okx.com${requestPath}`, \n            params, \n            { headers }\n        );\n\n        if (response.data.code !== \"0\") {\n            throw new Error(`Simulation failed: ${response.data.msg || \"Unknown simulation error\"}`);\n        }\n\n        const simulationResult = response.data.data[0];\n        \n        // Check simulation success\n        if (simulationResult.success === false) {\n            console.error('Transaction simulation failed:', simulationResult.error);\n            throw new Error(`Transaction would fail: ${simulationResult.error}`);\n        }\n\n        console.log('Transaction simulation successful');\n        console.log(`Estimated gas used: ${simulationResult.gasUsed || 'N/A'}`);\n        \n        if (simulationResult.logs) {\n            console.log('Simulation logs:', simulationResult.logs);\n        }\n\n        return simulationResult;\n    } catch (error) {\n        console.error(\"Error simulating transaction:\", error);\n        throw error;\n    }\n}\n```\n\n## 7\\. 广播交易[#](#7.-广播交易)\n\n创建计算 Gas 限制的实用函数 获取交易 Gas 限制的方法有两种：使用标准 RPC 调用或利用 交易上链 API。\n\n方法 1：使用 交易上链 API 估算 Gas\n\n第一种方法利用 OKX 的 交易上链 API，该 API 可以提供比标准方法更准确的 Gas 估算。\n\n```typescript\n/**\n * Get transaction gas limit from Onchain gateway API\n * @param fromAddress - Sender address\n * @param toAddress - Target contract address\n * @param txAmount - Transaction amount (0 for approvals)\n * @param inputData - Transaction calldata\n * @returns Estimated gas limit\n */\nasync function getGasLimit(\n  fromAddress: string,\n  toAddress: string,\n  txAmount: string = '0',\n  inputData: string = ''\n): Promise<string> {\n  try {\n    const path = 'dex/pre-transaction/gas-limit';\n    const url = `https://web3.okx.com/api/v5/${path}`;\n\n    const body = {\n      chainIndex: chainId,\n      fromAddress: fromAddress,\n      toAddress: toAddress,\n      txAmount: txAmount,\n      extJson: {\n        inputData: inputData\n      }\n    };\n\n    // Prepare authentication with body included in signature\n    const bodyString = JSON.stringify(body);\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n    const response = await axios.post(url, body, { headers });\n\n    if (response.data.code === '0') {\n      return response.data.data[0].gasLimit;\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to get gas limit:', (error as Error).message);\n    throw error;\n  }\n}\n```\n\n方法 2：使用 RPC 估算 Gas 限制\n\n第二种方法利用标准的 Web3 RPC 调用来估算交易所需的 Gas。\n\n```typescript\nconst gasLimit = await web3.eth.estimateGas({\n  from: WALLET_ADDRESS,\n  to: tokenAddress,\n  value: '0',\n  data: swapData.data\n});\n\n// Add 20% buffer\nconst gasLimit = (BigInt(gasLimit) * BigInt(12) / BigInt(10)).toString();\n```\n\nBroadcasting Transactions with the Onchain Gateway API\n\nFor developers with access to the Onchain Gateway API, you can broadcast transactions directly through OKX's infrastructure. This method provides enhanced reliability and monitoring capabilities for high-volume trading operations.\n\nThe Broadcast API requires API is available to our whitelisted customers only. Please reach out to [dexapi@okx.com](mailto:dexapi@okx.com) to request access.\n\n```typescript\nimport { Web3 } from 'web3';\nimport axios from 'axios';\nimport * as dotenv from 'dotenv';\nimport CryptoJS from 'crypto-js';\n\n// Load environment variables\ndotenv.config();\n\n// Connect to Base network\nconst web3 = new Web3(process.env.EVM_RPC_URL || 'https://mainnet.base.org');\n\n// Your wallet information - REPLACE WITH YOUR OWN VALUES\nconst WALLET_ADDRESS = process.env.EVM_WALLET_ADDRESS || '';\nconst PRIVATE_KEY = process.env.EVM_PRIVATE_KEY || '';\n\n// Token addresses for swap on Base Chain\nconst ETH_ADDRESS = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'; // Native ETH\n\n// Chain ID for Base Chain\nconst chainId = '8453';\n\n// API URL\nconst baseUrl = 'https://web3.okx.com/api/v5/';\n\n// Define interfaces\ninterface GasLimitApiResponse {\n  code: string;\n  msg?: string;\n  data: Array<{\n    gasLimit: string;\n  }>;\n}\n\n// Interface for broadcast API response\ninterface BroadcastApiResponse {\n  code: string;\n  msg?: string;\n  data: Array<{\n    orderId: string;\n  }>;\n}\n\n/**\n * Generate API authentication headers\n */\nfunction getHeaders(timestamp: string, method: string, requestPath: string, queryString = \"\", body = \"\") {\n    const apiKey = process.env.OKX_API_KEY;\n    const secretKey = process.env.OKX_SECRET_KEY;\n    const apiPassphrase = process.env.OKX_API_PASSPHRASE;\n    const projectId = process.env.OKX_PROJECT_ID;\n\n    if (!apiKey || !secretKey || !apiPassphrase || !projectId) {\n        throw new Error(\"Missing required environment variables for API authentication\");\n    }\n\n    const stringToSign = timestamp + method + requestPath + (queryString || body);\n\n    return {\n        \"Content-Type\": \"application/json\",\n        \"OK-ACCESS-KEY\": apiKey,\n        \"OK-ACCESS-SIGN\": CryptoJS.enc.Base64.stringify(\n            CryptoJS.HmacSHA256(stringToSign, secretKey)\n        ),\n        \"OK-ACCESS-TIMESTAMP\": timestamp,\n        \"OK-ACCESS-PASSPHRASE\": apiPassphrase,\n        \"OK-ACCESS-PROJECT\": projectId,\n    };\n}\n\n/**\n * Get transaction gas limit from Onchain gateway API\n * @param fromAddress - Sender address\n * @param toAddress - Target contract address\n * @param txAmount - Transaction amount (0 for approvals)\n * @param inputData - Transaction calldata\n * @returns Estimated gas limit\n */\nasync function getGasLimit(\n  fromAddress: string,\n  toAddress: string,\n  txAmount: string = '0',\n  inputData: string = ''\n): Promise<string> {\n  const path = 'dex/pre-transaction/gas-limit';\n  const url = `${baseUrl}${path}`;\n  const body = { chainIndex: chainId, fromAddress, toAddress, txAmount, extJson: { inputData } };\n  \n  const bodyString = JSON.stringify(body);\n  const timestamp = new Date().toISOString();\n  const headers = getHeaders(timestamp, 'POST', `/api/v5/${path}`, \"\", bodyString);\n\n  const response = await axios.post<GasLimitApiResponse>(url, body, { headers });\n  if (response.data.code === '0') {\n    return response.data.data[0].gasLimit;\n  }\n  throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n}\n\n/**\n * Get swap data from OKX API\n */\nasync function getSwapData(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage = '0.5'\n) {\n    const path = 'dex/aggregator/swap';\n    const url = `${baseUrl}${path}`;\n    const params = { chainIndex: chainId, fromTokenAddress, toTokenAddress, amount, slippage, userWalletAddress: WALLET_ADDRESS };\n    \n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const timestamp = new Date().toISOString();\n    const headers = getHeaders(timestamp, 'GET', `/api/v5/${path}`, queryString);\n\n    const response = await axios.get(`${url}${queryString}`, { headers });\n    const responseData = response.data as any;\n    if (responseData.code === '0') {\n        return responseData.data[0];\n    }\n    throw new Error(`Swap API Error: ${responseData.msg || 'Unknown error'}`);\n}\n\n/**\n * Build and sign transaction using gas limit\n */\nasync function buildAndSignTransaction(swapData: any, gasLimit: string): Promise<any> {\n    const gasPrice = await web3.eth.getGasPrice();\n    const nonce = await web3.eth.getTransactionCount(WALLET_ADDRESS, 'pending');\n    \n    const transaction = {\n        from: swapData.tx.from,\n        to: swapData.tx.to,\n        data: swapData.tx.data,\n        value: swapData.tx.value || '0x0',\n        gas: gasLimit,\n        gasPrice: gasPrice.toString(),\n        nonce: Number(nonce),\n        chainId: parseInt(chainId)\n    };\n\n    return await web3.eth.accounts.signTransaction(transaction, PRIVATE_KEY);\n}\n\n/**\n * Broadcast transaction using Onchain Gateway API\n */\nasync function broadcastTransaction(signedTx: any, chainId: string, walletAddress: string): Promise<string> {\n    const path = 'dex/pre-transaction/broadcast-transaction';\n    const url = `${baseUrl}${path}`;\n    const rawTxHex = typeof signedTx.rawTransaction === 'string' ? signedTx.rawTransaction : web3.utils.bytesToHex(signedTx.rawTransaction);\n    const body = { signedTx: rawTxHex, chainIndex: chainId, address: walletAddress };\n    \n    const bodyString = JSON.stringify(body);\n    const timestamp = new Date().toISOString();\n    const headers = getHeaders(timestamp, 'POST', `/api/v5/${path}`, \"\", bodyString);\n\n    const response = await axios.post<BroadcastApiResponse>(url, body, { headers });\n    if (response.data.code === '0') {\n        return response.data.data[0].orderId;\n    }\n    throw new Error(`Broadcast API Error: ${response.data.msg || 'Unknown error'}`);\n}\n\nasync function main() {\n    try {\n        console.log('EVM Gas Limit and Broadcast');\n        console.log('================================');\n\n        // Validate environment variables\n        if (!WALLET_ADDRESS || !PRIVATE_KEY) {\n            throw new Error('Missing wallet address or private key in environment variables');\n        }\n\n        console.log(`Wallet Address: ${WALLET_ADDRESS}`);\n        console.log(`Chain ID: ${chainId}`);\n        console.log(`RPC URL: ${process.env.EVM_RPC_URL || 'https://mainnet.base.org'}`);\n\n        // Example parameters\n        const fromToken = ETH_ADDRESS;\n        const toToken = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'; // USDC on Base\n        const amount = '100000000000000'; // 0.0001 ETH in wei\n        const slippage = '0.05'; // 0.5%\n\n        // Step 1: Get swap data\n        const swapData = await getSwapData(fromToken, toToken, amount, slippage);\n        console.log('Swap data obtained');\n\n        // Step 2: Get gas limit\n        const gasLimit = await getGasLimit(\n            swapData.tx.from,\n            swapData.tx.to,\n            swapData.tx.value || '0',\n            swapData.tx.data\n        );\n        console.log('Gas limit obtained', gasLimit);\n\n        // Step 3: Build and sign transaction\n        const signedTx = await buildAndSignTransaction(swapData, gasLimit);\n        console.log('Transaction built and signed');\n\n        // Step 4: Broadcast transaction\n        try {\n            const orderId = await broadcastTransaction(signedTx, chainId, swapData.tx.from);\n            console.log(`Transaction broadcast successful. Order ID: ${orderId}`);\n        } catch (broadcastError: any) {\n            if (broadcastError.message.includes('API registration and whitelist required')) {\n                console.log('Broadcast failed - API registration and whitelist required');\n                console.log('Gas limit obtained successfully:', gasLimit);\n            } else {\n                throw broadcastError;\n            }\n        }\n        \n    } catch (error) {\n        console.error('Main execution failed:', (error as Error).message);\n        process.exit(1);\n    }\n}\n\n// Run the script\nif (require.main === module) {\n    main();\n}\n\nexport {\n    getSwapData,\n    getGasLimit,\n    broadcastTransaction\n}; \n```\n\nAlternative: Broadcasting Transactions Using Standard RPC For developers who prefer using standard blockchain RPC methods or do not have yet requested API whitelisting, you can broadcast transactions directly to the network using Web3 RPC calls.\n\n```typescript\n/**\n * Execute token swap\n * @param fromTokenAddress - Source token address\n * @param toTokenAddress - Destination token address\n * @param amount - Amount to swap\n * @param slippage - Maximum slippage\n * @returns Transaction hash\n */\nasync function executeSwap(\n  fromTokenAddress: string,\n  toTokenAddress: string,\n  amount: string,\n  slippage: string = '0.005'\n): Promise<string> {\n  // 1. Check allowance and approve if necessary (skip for native token)\n  if (fromTokenAddress !== ETH_ADDRESS) {\n    await approveToken(fromTokenAddress, amount);\n  }\n\n  // 2. Get swap transaction data\n  const swapData = await getSwapTransaction(fromTokenAddress, toTokenAddress, amount, WALLET_ADDRESS, slippage);\n  \n  const txData = swapData.tx;\n  console.log(\"Swap TX data received\");\n\n  // 3. Get accurate gas limit\n  const gasLimit = await getGasLimit(\n    WALLET_ADDRESS,\n    txData.to,\n    txData.value || '0',\n    txData.data\n  );\n  console.log(\"Gas limit received\");\n\n  // 4. Get current nonce\n  const nonce = await web3.eth.getTransactionCount(WALLET_ADDRESS, 'latest');\n  console.log(\"Nonce received\");\n\n  // 5. Get current gas price and adjust for faster confirmation\n  const gasPrice = await web3.eth.getGasPrice();\n  const adjustedGasPrice = BigInt(gasPrice) * BigInt(15) / BigInt(10); // 1.5x for faster confirmation\n  console.log(\"Gas price received\");\n\n  // 6. Create transaction object\n  const txObject = {\n    from: WALLET_ADDRESS,\n    to: txData.to,\n    data: txData.data,\n    value: txData.value || '0',\n    gas: gasLimit,\n    gasPrice: adjustedGasPrice.toString(),\n    nonce: nonce\n  };\n  console.log(\"TX build complete\");\n\n  // 7. Sign and broadcast transaction using RPC\n  const signedTx = await web3.eth.accounts.signTransaction(txObject, PRIVATE_KEY);\n  console.log(\"TX signed\");\n  \n  const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n  console.log(`Transaction successful: ${receipt.transactionHash}`);\n  \n  return receipt.transactionHash;\n}\n```\n\n## 8\\. 追踪交易[#](#8.-追踪交易)\n\n最后，创建一个交易追踪系统，对于基本交易的状态确认，请选择第一个（8.1 部分）；当您需要有关兑换执行本身的详细信息时，请选择第二个（8.2部分）。\n\n6.1 使用 交易上链 API 交易上链 API 通过 /dex/post-transaction/orders 提供交易追踪功能。使用广播 API 返回的订单ID，并设置简单的状态代码（1：待处理，2：成功，3：失败），即可追踪交易在 OKX 系统中的进展。\n\n```typescript\n// Define error info interface\ninterface TxErrorInfo {\n  error: string;\n  message: string;\n  action: string;\n}\n\n/**\n * Tracking transaction confirmation status using the Onchain gateway API\n * @param orderId - Order ID from broadcast response\n * @param intervalMs - Polling interval in milliseconds\n * @param timeoutMs - Maximum time to wait\n * @returns Final transaction confirmation status\n */\nasync function trackTransaction(\n  orderId: string,\n  intervalMs: number = 5000,\n  timeoutMs: number = 300000\n): Promise<any> {\n  console.log(`Tracking transaction with Order ID: ${orderId}`);\n\n  const startTime = Date.now();\n  let lastStatus = '';\n\n  while (Date.now() - startTime < timeoutMs) {\n    // Get transaction status\n    try {\n      const path = 'dex/post-transaction/orders';\n      const url = `https://web3.okx.com/api/v5/${path}`;\n\n      const params = {\n        orderId: orderId,\n        chainIndex: chainId,\n        address: WALLET_ADDRESS,\n        limit: '1'\n      };\n\n      // Prepare authentication\n      const timestamp = new Date().toISOString();\n      const requestPath = `/api/v5/${path}`;\n      const queryString = \"?\" + new URLSearchParams(params).toString();\n      const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n      const response = await axios.get(url, { params, headers });\n\n      if (response.data.code === '0' && response.data.data && response.data.data.length > 0) {\n        if (response.data.data[0].orders && response.data.data[0].orders.length > 0) {\n          const txData = response.data.data[0].orders[0];\n          \n          // Use txStatus to match the API response\n          const status = txData.txStatus;\n\n          // Only log when status changes\n          if (status !== lastStatus) {\n            lastStatus = status;\n\n            if (status === '1') {\n              console.log(`Transaction pending: ${txData.txHash || 'Hash not available yet'}`);\n            } else if (status === '2') {\n              console.log(`Transaction successful: https://web3.okx.com/explorer/base/tx/${txData.txHash}`);\n              return txData;\n            } else if (status === '3') {\n              const failReason = txData.failReason || 'Unknown reason';\n              const errorMessage = `Transaction failed: ${failReason}`;\n\n              console.error(errorMessage);\n\n              const errorInfo = handleTransactionError(txData);\n              console.log(`Error type: ${errorInfo.error}`);\n              console.log(`Suggested action: ${errorInfo.action}`);\n\n              throw new Error(errorMessage);\n            }\n          }\n        } else {\n          console.log(`No orders found for Order ID: ${orderId}`);\n        }\n      }\n    } catch (error) {\n      console.warn('Error checking transaction status:', (error as Error).message);\n    }\n\n    // Wait before next check\n    await new Promise(resolve => setTimeout(resolve, intervalMs));\n  }\n\n  throw new Error('Transaction tracking timed out');\n}\n\n/**\n * Comprehensive error handling with failReason\n * @param txData - Transaction data from post-transaction/orders\n * @returns Structured error information\n */\nfunction handleTransactionError(txData: any): TxErrorInfo {\n  const failReason = txData.failReason || 'Unknown reason';\n\n  // Log the detailed error\n  console.error(`Transaction failed with reason: ${failReason}`);\n\n  // Default error handling\n  return {\n    error: 'TRANSACTION_FAILED',\n    message: failReason,\n    action: 'Try again or contact support'\n  };\n}\n```\n\n8.2 如需更详细的兑换信息，您可以使用 SWAP API：\n\nSWAP API 使用 /dex/aggregator/history 提供全面交易跟踪\n\n```typescript\n/**\n * Track transaction using SWAP API\n * @param chainId - Chain ID (e.g., 1 for Ethereum Mainnet)\n * @param txHash - Transaction hash\n * @returns Transaction details\n */\nasync function trackTransactionWithSwapAPI(chainId: string, txHash: string): Promise<any> {\n  try {\n    const path = 'dex/aggregator/history';\n    const url = `${baseUrl}${path}`;\n\n    const params = {\n      chainId: chainId,\n      txHash: txHash,\n      isFromMyProject: 'true'\n    };\n\n    // Prepare authentication\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n    const response = await axios.get(url, { params, headers });\n\n    if (response.data.code === '0') {\n      const txData = response.data.data[0];\n      const status = txData.status;\n\n      if (status === 'pending') {\n        console.log(`Transaction is still pending: ${txHash}`);\n        return { status: 'pending', details: txData };\n      } else if (status === 'success') {\n        console.log(`Transaction successful!`);\n        console.log(`From: ${txData.fromTokenDetails.symbol} - Amount: ${txData.fromTokenDetails.amount}`);\n        console.log(`To: ${txData.toTokenDetails.symbol} - Amount: ${txData.toTokenDetails.amount}`);\n        console.log(`Transaction Fee: ${txData.txFee}`);\n        console.log(`Explorer URL: https://basescan.org/tx/${txHash}`);\n        return { status: 'success', details: txData };\n      } else if (status === 'failure') {\n        console.error(`Transaction failed: ${txData.errorMsg || 'Unknown reason'}`);\n        return { status: 'failure', details: txData };\n      }\n      \n      return txData;\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to track transaction status:', (error as Error).message);\n    throw error;\n  }\n}\n```\n\n## 9\\. 完整实现[#](#9.-完整实现)\n\n这是一个完整的实现示例：\n\n```typescript\nimport { Web3 } from 'web3';\nimport * as axios from 'axios';\nimport * as dotenv from 'dotenv';\nimport * as CryptoJS from 'crypto-js';\n\n// Load environment variables\ndotenv.config();\n\n// Connect to Base network\nconst web3 = new Web3(process.env.EVM_RPC_URL || 'https://mainnet.base.org');\n\n// Your wallet information - REPLACE WITH YOUR OWN VALUES\nconst WALLET_ADDRESS: string = process.env.EVM_WALLET_ADDRESS || '';\nconst PRIVATE_KEY: string = process.env.EVM_PRIVATE_KEY || '';\n\n// Token addresses for swap on Base Chain\nconst ETH_ADDRESS: string = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE'; // Native ETH\n\n// Chain ID for Base Chain\nconst chainId: string = '8453';\n\n// API URL\nconst baseUrl: string = 'https://web3.okx.com/api/v5/';\n\n// Define interfaces\ninterface TokenInfo {\n    tokenSymbol: string;\n    decimal: string;\n    tokenUnitPrice: string;\n}\n\n// Interface for gas limit API response\ninterface GasLimitApiResponse {\n  code: string;\n  msg?: string;\n  data: Array<{\n    gasLimit: string;\n  }>;\n}\n\n// Interface for simulation API response\ninterface SimulationApiResponse {\n  code: string;\n  msg?: string;\n  data: Array<{\n    intention: string;\n    gasUsed?: string;\n    failReason?: string;\n    assetChange?: Array<{\n      assetType: string;\n      name: string;\n      symbol: string;\n      decimals: number;\n      address: string;\n      imageUrl: string;\n      rawValue: string;\n    }>;\n    risks?: Array<any>;\n  }>;\n}\n\n// Interface for broadcast API response\ninterface BroadcastApiResponse {\n  code: string;\n  msg?: string;\n  data: Array<{\n    orderId: string;\n  }>;\n}\n\n// Define error info interface\ninterface TxErrorInfo {\n  error: string;\n  message: string;\n  action: string;\n}\n\n/**\n * Generate API authentication headers\n */\nfunction getHeaders(timestamp: string, method: string, requestPath: string, queryString = \"\", body = \"\") {\n    const apiKey = process.env.OKX_API_KEY;\n    const secretKey = process.env.OKX_SECRET_KEY;\n    const apiPassphrase = process.env.OKX_API_PASSPHRASE;\n    const projectId = process.env.OKX_PROJECT_ID;\n\n    if (!apiKey || !secretKey || !apiPassphrase || !projectId) {\n        throw new Error(\"Missing required environment variables for API authentication\");\n    }\n\n    const stringToSign = timestamp + method + requestPath + (queryString || body);\n\n    return {\n        \"Content-Type\": \"application/json\",\n        \"OK-ACCESS-KEY\": apiKey,\n        \"OK-ACCESS-SIGN\": CryptoJS.enc.Base64.stringify(\n            CryptoJS.HmacSHA256(stringToSign, secretKey)\n        ),\n        \"OK-ACCESS-TIMESTAMP\": timestamp,\n        \"OK-ACCESS-PASSPHRASE\": apiPassphrase,\n        \"OK-ACCESS-PROJECT\": projectId,\n    };\n}\n\n/**\n * Get transaction gas limit from Onchain gateway API\n * @param fromAddress - Sender address\n * @param toAddress - Target contract address\n * @param txAmount - Transaction amount (0 for approvals)\n * @param inputData - Transaction calldata\n * @returns Estimated gas limit\n */\nasync function getGasLimit(\n  fromAddress: string,\n  toAddress: string,\n  txAmount: string = '0',\n  inputData: string = ''\n): Promise<string> {\n  try {\n    console.log('Getting gas limit from Onchain Gateway API...');\n    \n    const path = 'dex/pre-transaction/gas-limit';\n    const url = `${baseUrl}${path}`;\n\n    const body = {\n      chainIndex: chainId,\n      fromAddress: fromAddress,\n      toAddress: toAddress,\n      txAmount: txAmount,\n      extJson: {\n        inputData: inputData\n      }\n    };\n\n    // Prepare authentication with body included in signature\n    const bodyString = JSON.stringify(body);\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n    const response = await axios.post<GasLimitApiResponse>(url, body, { headers });\n\n    console.log('Gas Limit API Response:');\n    console.log(JSON.stringify(response.data, null, 2));\n\n    if (response.data.code === '0') {\n      const gasLimit = response.data.data[0].gasLimit;\n      console.log(`Gas Limit obtained: ${gasLimit}`);\n      return gasLimit;\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to get gas limit:', (error as Error).message);\n    throw error;\n  }\n}\n\n/**\n * Get swap data from OKX API\n */\nasync function getSwapData(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage = '0.5'\n) {\n    try {\n        console.log('Getting swap data from OKX API...');\n        \n        const path = 'dex/aggregator/swap';\n        const url = `${baseUrl}${path}`;\n\n        const params = {\n            chainIndex: chainId,\n            fromTokenAddress: fromTokenAddress,\n            toTokenAddress: toTokenAddress,\n            amount: amount,\n            slippage: slippage,\n            userWalletAddress: WALLET_ADDRESS\n        };\n\n        console.log('Swap API Request Parameters:');\n        console.log(JSON.stringify(params, null, 2));\n\n        // Prepare authentication with query string\n        const queryString = \"?\" + new URLSearchParams(params).toString();\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n        const response = await axios.get(`${url}${queryString}`, { headers });\n\n        console.log('Swap API Response:');\n        console.log(JSON.stringify(response.data, null, 2));\n\n        const responseData = response.data as any;\n        if (responseData.code === '0') {\n            return responseData.data[0];\n        } else {\n            throw new Error(`Swap API Error: ${responseData.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Failed to get swap data:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Simulate transaction using Onchain Gateway API\n */\nasync function simulateTransaction(swapData: any) {\n    try {\n        console.log('Simulating transaction with Onchain Gateway API...');\n        \n        const path = 'dex/pre-transaction/simulate';\n        const url = `${baseUrl}${path}`;\n\n        const body = {\n            chainIndex: chainId,\n            fromAddress: swapData.tx.from,\n            toAddress: swapData.tx.to,\n            txAmount: swapData.tx.value || '0',\n            extJson: {\n                inputData: swapData.tx.data\n            }\n        };\n\n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post<SimulationApiResponse>(url, body, { headers });\n\n        console.log('Simulation API Response:');\n        console.log(JSON.stringify(response.data, null, 2));\n\n        if (response.data.code === '0') {\n            const simulationResult = response.data.data[0];\n            // Check if simulation was successful (no failReason or empty failReason)\n            if (!simulationResult.failReason || simulationResult.failReason === '') {\n                console.log(`Transaction simulation successful. Gas used: ${simulationResult.gasUsed}`);\n                return simulationResult;\n            } else {\n                throw new Error(`Simulation failed: ${simulationResult.failReason}`);\n            }\n        } else {\n            throw new Error(`Simulation API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('Transaction simulation failed:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Broadcast transaction using Onchain Gateway API with RPC fallback\n */\nasync function broadcastTransaction(signedTx: any, chainId: string, walletAddress: string): Promise<string> {\n    try {\n        console.log('Broadcasting transaction via Onchain Gateway API...');\n        \n        const path = 'dex/pre-transaction/broadcast-transaction';\n        const url = `${baseUrl}${path}`;\n\n        // Convert rawTransaction to hex string\n        const rawTxHex = typeof signedTx.rawTransaction === 'string' \n            ? signedTx.rawTransaction \n            : web3.utils.bytesToHex(signedTx.rawTransaction);\n\n        const body = {\n            signedTx: rawTxHex,\n            chainIndex: chainId,\n            address: walletAddress\n            // See [MEV Section](#10-mev-protection) for MEV protection settings\n\n        };\n\n        console.log('Broadcast API Request Body:');\n        console.log(JSON.stringify(body, null, 2));\n\n        // Prepare authentication with body included in signature\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post<BroadcastApiResponse>(url, body, { headers });\n\n        console.log('Broadcast API Response:');\n        console.log(JSON.stringify(response.data, null, 2));\n\n        if (response.data.code === '0') {\n            const orderId = response.data.data[0].orderId;\n            console.log(`Transaction broadcast successful. Order ID: ${orderId}`);\n            return orderId;\n        } else {\n            throw new Error(`Broadcast API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('API broadcast failed, trying RPC fallback:', (error as Error).message);\n        \n        // Fallback to RPC broadcast\n        try {\n            console.log('Broadcasting via RPC fallback...');\n            const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n            console.log(`RPC broadcast successful. Transaction hash: ${receipt.transactionHash}`);\n            return receipt.transactionHash.toString();\n        } catch (rpcError) {\n            console.error('RPC broadcast also failed:', (rpcError as Error).message);\n            throw new Error(`Both API and RPC broadcast failed. API Error: ${(error as Error).message}, RPC Error: ${(rpcError as Error).message}`);\n        }\n    }\n}\n\n/**\n * Execute swap with full transaction flow\n */\nasync function executeSwap(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.05'\n): Promise<string> {\n    try {\n        console.log('Starting swap execution...');\n        // Step 1: Get swap data\n        const swapData = await getSwapData(fromTokenAddress, toTokenAddress, amount, slippage);\n        console.log('Swap data obtained');\n\n        // Step 2: Simulate transaction\n        const simulationResult = await simulateTransaction(swapData);\n        console.log('Transaction simulation completed');\n        console.log('Simulation result', simulationResult.intention);\n\n        // Step 3: Get gas limit\n        const gasLimit = await getGasLimit(\n            swapData.tx.from,\n            swapData.tx.to,\n            swapData.tx.value || '0',\n            swapData.tx.data\n        );\n\n        // Step 4: Get current gas price\n        const gasPrice = await web3.eth.getGasPrice();\n        console.log(`Current gas price: ${web3.utils.fromWei(gasPrice, 'gwei')} gwei`);\n\n        // Step 5: Get nonce\n        const nonce = await web3.eth.getTransactionCount(WALLET_ADDRESS, 'pending');\n        console.log(`Nonce: ${nonce}`);\n\n        // Step 6: Build transaction\n        const transaction = {\n            from: swapData.tx.from,\n            to: swapData.tx.to,\n            data: swapData.tx.data,\n            value: swapData.tx.value || '0x0',\n            gas: gasLimit,\n            gasPrice: gasPrice.toString(),\n            nonce: Number(nonce),\n            chainId: parseInt(chainId)\n        };\n\n        console.log('Transaction object:');\n        console.log(JSON.stringify(transaction, null, 2));\n\n        // Step 7: Sign transaction\n        console.log('Signing transaction...');\n        const signedTx = await web3.eth.accounts.signTransaction(transaction, PRIVATE_KEY);\n        console.log('Transaction signed');\n\n        // Step 8: Broadcast transaction\n        const txHash = await broadcastTransaction(signedTx, chainId, WALLET_ADDRESS);\n        console.log(`Transaction broadcast successful. Hash: ${txHash}`);\n\n        // Step 9: Track transaction\n        console.log('Tracking transaction status...');\n        const trackingResult = await trackTransaction(txHash);\n        console.log('Transaction tracking completed');\n        console.log('Tracking result', trackingResult);\n\n        return txHash;\n    } catch (error) {\n        console.error('Swap execution failed:', (error as Error).message);\n        throw error;\n    }\n}\n\n/**\n * Execute swap with simulation and detailed logging\n */\nasync function executeSwapWithSimulation(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.05'\n): Promise<any> {\n    try {\n        console.log('Starting swap execution with simulation...');\n        \n        const txHash = await executeSwap(fromTokenAddress, toTokenAddress, amount, slippage);\n        \n        console.log('Swap execution completed successfully!');\n        console.log(`Transaction Hash: ${txHash}`);\n        \n        return { success: true, txHash };\n    } catch (error) {\n        console.error('Swap execution failed:', (error as Error).message);\n        return { success: false, error: (error as Error).message };\n    }\n}\n\n/**\n * Tracking transaction confirmation status using the Onchain gateway API\n * @param orderId - Order ID from broadcast response\n * @param intervalMs - Polling interval in milliseconds\n * @param timeoutMs - Maximum time to wait\n * @returns Final transaction confirmation status\n */\nasync function trackTransaction(\n  orderId: string,\n  intervalMs: number = 5000,\n  timeoutMs: number = 300000\n): Promise<any> {\n  console.log(`Tracking transaction with Order ID: ${orderId}`);\n\n  const startTime = Date.now();\n  let lastStatus = '';\n\n  while (Date.now() - startTime < timeoutMs) {\n    try {\n      const path = 'dex/post-transaction/orders';\n      const url = `https://web3.okx.com/api/v5/${path}`;\n\n      const params = {\n        orderId: orderId,\n        chainIndex: chainId,\n        address: WALLET_ADDRESS,\n        limit: '1'\n      };\n\n      const timestamp = new Date().toISOString();\n      const requestPath = `/api/v5/${path}`;\n      const queryString = \"?\" + new URLSearchParams(params).toString();\n      const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n      const response = await axios.get(url, { params, headers });\n\n      const responseData = response.data as any;\n      if (responseData.code === '0' && responseData.data && responseData.data.length > 0) {\n        if (responseData.data[0].orders && responseData.data[0].orders.length > 0) {\n          const txData = responseData.data[0].orders[0];\n          const status = txData.txStatus;\n\n          if (status !== lastStatus) {\n            lastStatus = status;\n\n            if (status === '1') {\n              console.log(`Transaction pending: ${txData.txHash || 'Hash not available yet'}`);\n            } else if (status === '2') {\n              console.log(`Transaction successful: https://web3.okx.com/explorer/base/tx/${txData.txHash}`);\n              return txData;\n            } else if (status === '3') {\n              const failReason = txData.failReason || 'Unknown reason';\n              const errorMessage = `Transaction failed: ${failReason}`;\n\n              console.error(errorMessage);\n\n              const errorInfo = handleTransactionError(txData);\n              console.log(`Error type: ${errorInfo.error}`);\n              console.log(`Suggested action: ${errorInfo.action}`);\n\n              throw new Error(errorMessage);\n            }\n          }\n        } else {\n          console.log(`No orders found for Order ID: ${orderId}`);\n        }\n      }\n    } catch (error) {\n      console.warn('Error checking transaction status:', (error as Error).message);\n    }\n\n    await new Promise(resolve => setTimeout(resolve, intervalMs));\n  }\n\n  throw new Error('Transaction tracking timed out');\n}\n\n/**\n * Comprehensive error handling with failReason\n * @param txData - Transaction data from post-transaction/orders\n * @returns Structured error information\n */\nfunction handleTransactionError(txData: any): TxErrorInfo {\n  const failReason = txData.failReason || 'Unknown reason';\n\n  console.error(`Transaction failed with reason: ${failReason}`);\n\n  return {\n    error: 'TRANSACTION_FAILED',\n    message: failReason,\n    action: 'Try again or contact support'\n  };\n}\n\n// ======== Main Execution ========\n\nasync function simulateOnly(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.5'\n): Promise<any> {\n    try {\n        console.log('Starting simulation-only mode...');\n        console.log(`Simulation Details:`);\n        console.log(`   From Token: ${fromTokenAddress}`);\n        console.log(`   To Token: ${toTokenAddress}`);\n        console.log(`   Amount: ${amount}`);\n        console.log(`   Slippage: ${slippage}%`);\n\n        // Step 1: Get swap data\n        const swapData = await getSwapData(fromTokenAddress, toTokenAddress, amount, slippage);\n        console.log('Swap data obtained');\n\n        // Step 2: Simulate transaction\n        const simulationResult = await simulateTransaction(swapData);\n        console.log('Transaction simulation completed');\n\n        // Step 3: Get gas limit\n        const gasLimit = await getGasLimit(\n            swapData.tx.from,\n            swapData.tx.to,\n            swapData.tx.value || '0',\n            swapData.tx.data\n        );\n\n        return {\n            success: true,\n            swapData,\n            simulationResult,\n            gasLimit,\n            estimatedGasUsed: simulationResult.gasUsed,\n        };\n    } catch (error) {\n        console.error('Simulation failed:', (error as Error).message);\n        return { success: false, error: (error as Error).message };\n    }\n}\n\nasync function main() {\n    try {\n        console.log('EVM Swap Tools with Onchain Gateway API');\n        console.log('=====================================');\n\n        // Validate environment variables\n        if (!WALLET_ADDRESS || !PRIVATE_KEY) {\n            throw new Error('Missing wallet address or private key in environment variables');\n        }\n\n        console.log(`Wallet Address: ${WALLET_ADDRESS}`);\n        console.log(`Chain ID: ${chainId}`);\n        console.log(`RPC URL: ${process.env.EVM_RPC_URL || 'https://mainnet.base.org'}`);\n\n        // Parse command line arguments\n        const args = process.argv.slice(2);\n        const mode = args[0] || 'simulate'; // Default to simulate mode\n        \n        // Example parameters\n        const fromToken = ETH_ADDRESS;\n        const toToken = '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913'; // USDC on Base\n        const amount = '100000000000000'; // 0.0001 ETH in wei\n        const slippage = '0.05'; // 0.5%\n\n        console.log('\\nConfiguration:');\n        console.log(`   From: ${fromToken} (ETH)`);\n        console.log(`   To: ${toToken} (USDC)`);\n        console.log(`   Amount: ${web3.utils.fromWei(amount, 'ether')} ETH`);\n        console.log(`   Slippage: ${slippage}%`);\n        console.log(`   Mode: ${mode}`);\n\n        let result;\n        \n        switch (mode.toLowerCase()) {\n            case 'simulate':\n            case 'sim':\n                result = await simulateOnly(fromToken, toToken, amount, slippage);\n                break;\n            case 'execute':\n            case 'exec':\n                result = await executeSwapWithSimulation(fromToken, toToken, amount, slippage);\n                break;\n            default:\n                console.log('\\nAvailable modes:');\n                console.log('   simulate/sim  - Only simulate the transaction');\n                console.log('   execute/exec  - Execute the full swap');\n                console.log('\\nExample: npm run evm-swap simulate');\n                return;\n        }\n        \n        if (result.success) {\n            console.log('\\nOperation completed successfully!');\n            if (mode === 'simulate' || mode === 'sim') {\n                console.log(`Gas Limit: ${result.gasLimit}`);\n            } else {\n                console.log(`Transaction Hash: ${result.txHash}`);\n            }\n        } else {\n            console.log('\\nOperation failed!');\n            console.log(`Error: ${result.error}`);\n        }\n    } catch (error) {\n        console.error('Main execution failed:', (error as Error).message);\n        process.exit(1);\n    }\n}\n\n// Run the script\nif (require.main === module) {\n    main();\n}\n\nexport {\n    executeSwap,\n    executeSwapWithSimulation,\n    simulateOnly,\n    getSwapData,\n    simulateTransaction,\n    getGasLimit,\n    broadcastTransaction,\n    trackTransaction\n};\n\n\n```\n\nYou can run this script using `evm-swap.ts sim` or `evm-swap.ts exec`.\n\n`sim` simulates a transaction using swap data using the transaction simulation API and retruns `gasLimit` info `exec` executes a transaction using the broadcast API\n\n## 10\\. MEV Protection[#](#10.-mev-protection)\n\n### MEV Protection with Broadcast Transaction API[#](#mev-protection-with-broadcast-transaction-api)\n\nThe OKX Broadcast Transaction API provides built-in MEV protection capabilities to help safeguard your transactions from front-running and sandwich attacks. The Broadcast API is available to our whitelisted customers only. Please reach out to [dexapi@okx.com](mailto:dexapi@okx.com) to request access.\n\n**Disclaimer:** Your end-user's transaction can only be covered by the MEV protection feature if you actually utilise OKX Build's API services for that particular transaction. MEV protection is currently an experimental feature provided by third-parties and OKX Build does not guarantee the effectiveness and quality of such MEV protection.\n\n#### Adding MEV Protection[#](#adding-mev-protection)\n\nTo enable MEV protection on EVM chains, add the `extraData` field to your broadcast transaction request with `enableMevProtection: true`:\n\n```tsx\n/**\n * Broadcast transaction with MEV protection enabled for EVM chains\n */\nasync function broadcastTransactionWithMEV(\n    signedTx: string,\n    chainId: string = \"8453\", // Base chain\n    walletAddress: string,\n    enableMevProtection: boolean = true\n): Promise<string> {\n    try {\n        console.log('Broadcasting transaction with MEV protection...');\n\n        const path = 'dex/pre-transaction/broadcast-transaction';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const body = {\n            signedTx: signedTx,\n            chainIndex: chainId,\n            address: walletAddress,\n            extraData: JSON.stringify({\n                enableMevProtection: enableMevProtection\n            })\n        };\n\n        const bodyString = JSON.stringify(body);\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const headers = getHeaders(timestamp, 'POST', requestPath, \"\", bodyString);\n\n        const response = await axios.post(url, body, { headers });\n\n        if (response.data.code === '0') {\n            const orderId = response.data.data[0].orderId;\n            console.log(`Transaction broadcast with MEV protection. Order ID: ${orderId}`);\n            return orderId;\n        } else {\n            throw new Error(`Broadcast API Error: ${response.data.msg || 'Unknown error'}`);\n        }\n    } catch (error) {\n        console.error('MEV-protected broadcast failed:', error);\n        throw error;\n    }\n}\n```\n\n#### Usage Examples[#](#usage-examples)\n\n**Basic swap without MEV protection:**\n\n```tsx\n// Standard broadcast (no MEV protection) for Base chain\nconst orderId = await broadcastTransaction(signedTx, \"8453\", walletAddress);\n```\n\n**Swap with MEV protection enabled:**\n\n```tsx\n// With MEV protection on Base chain\nconst orderId = await broadcastTransactionWithMEVOptions(signedTx, \"8453\", walletAddress, true);\n```\n\n#### Integration with Complete Swap Flow[#](#integration-with-complete-swap-flow)\n\nHere's how to integrate MEV protection into your complete EVM swap execution:\n\n```tsx\n/**\n * Execute EVM swap with MEV protection\n */\nasync function executeSwapWithMEVProtection(\n    fromTokenAddress: string,\n    toTokenAddress: string,\n    amount: string,\n    slippage: string = '0.005',\n    enableMevProtection: boolean = true,\n    chainId: string = \"8453\" // Base chain\n): Promise<string> {\n    try {\n        // Step 1: Check allowance and approve if necessary (skip for native token)\n        if (fromTokenAddress !== ETH_ADDRESS) {\n            await approveToken(fromTokenAddress, amount);\n        }\n\n        // Step 2: Get swap transaction data\n        const swapData = await getSwapTransaction(fromTokenAddress, toTokenAddress, amount, WALLET_ADDRESS, slippage);\n        \n        const txData = swapData.tx;\n        console.log(\"Swap TX data received\");\n\n        // Step 3: Get current gas price and nonce\n        const gasPrice = await web3.eth.getGasPrice();\n        const adjustedGasPrice = BigInt(gasPrice) * BigInt(15) / BigInt(10); // 1.5x for faster confirmation\n        const nonce = await web3.eth.getTransactionCount(WALLET_ADDRESS, 'latest');\n\n        // Step 4: Create and sign transaction object\n        const txObject = {\n            from: WALLET_ADDRESS,\n            to: txData.to,\n            data: txData.data,\n            value: txData.value || '0',\n            gas: '300000', // Default gas limit\n            gasPrice: adjustedGasPrice.toString(),\n            nonce: nonce\n        };\n\n        const signedTx = await web3.eth.accounts.signTransaction(txObject, PRIVATE_KEY);\n        console.log(\"Transaction signed\");\n\n        // Step 5: Broadcast with MEV protection\n        const orderId = await broadcastTransactionWithMEVOptions(\n            signedTx.rawTransaction, \n            chainId, \n            WALLET_ADDRESS, \n            enableMevProtection\n        );\n\n        // Step 6: Track transaction\n        const result = await trackTransaction(orderId);\n        \n        return result.txHash;\n    } catch (error) {\n        console.error(\"MEV-protected swap failed:\", error);\n        throw error;\n    }\n}\n```\n\nMEV 保护功能与您现有的 EVM 和 Solana 兑换实现无缝集成，并为 Solana、Base、ETH 和 BSC 提供额外的安全保护，以抵御 MEV 攻击。\n\n## 方法2：SDK方法[#](#方法2：sdk方法)\n\n使用OKX DEX SDK提供了更简单的开发人员体验，同时保留了API方法的所有功能。SDK为您处理许多实现细节，包括重试逻辑、错误处理和交易管理。\n\n## 1.安装SDK[#](#1.安装sdk)\n\n```bash\nnpm install @okx-dex/okx-dex-sdk\n# or\nyarn add @okx-dex/okx-dex-sdk\n# or\npnpm add @okx-dex/okx-dex-sdk\n```\n\n## 2.设置环境[#](#2.设置环境)\n\n使用您的API凭据和钱包信息创建一个. env文件：\n\n```bash\n# OKX API Credentials\nOKX_API_KEY=your_api_key\nOKX_SECRET_KEY=your_secret_key\nOKX_API_PASSPHRASE=your_passphrase\nOKX_PROJECT_ID=your_project_id\n# EVM Configuration\nEVM_RPC_URL=your_evm_rpc_url\nEVM_WALLET_ADDRESS=your_evm_wallet_address\nEVM_PRIVATE_KEY=your_evm_private_key\n```\n\n## 3.初始化客户端[#](#3.初始化客户端)\n\n为您的DEX客户端创建一个文件（例如，DexClient. ts）：\n\n```typescript\n// DexClient.ts\nimport { OKXDexClient } from '@okx-dex/okx-dex-sdk';\nimport { createEVMWallet } from '@okx-dex/okx-dex-sdk/core/evm-wallet';\nimport { createWallet } from '@okx-dex/okx-dex-sdk/core/wallet';\nimport { Connection } from '@solana/web3.js';\nimport { ethers } from 'ethers';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\n// EVM setup (Ethereum, Base, Arbitrum, etc.)\nconst evmProvider = new ethers.JsonRpcProvider(process.env.EVM_RPC_URL!);\nconst evmWallet = createEVMWallet(process.env.EVM_PRIVATE_KEY!, evmProvider);\n\n// Initialize the client\nconst client = new OKXDexClient({\n    // API credentials (get from OKX Developer Portal)\n    apiKey: process.env.OKX_API_KEY!,\n    secretKey: process.env.OKX_SECRET_KEY!,\n    apiPassphrase: process.env.OKX_API_PASSPHRASE!,\n    projectId: process.env.OKX_PROJECT_ID!,\n    \n    // EVM configuration (works for all EVM chains)\n    evm: {\n        wallet: evmWallet\n    },\n})\n```\n\n## 4.调用SDK执行代币授权[#](#4.调用sdk执行代币授权)\n\n创建代币授权工具的功能：\n\n```typescript\n// approval.ts\nimport { client } from './DexClient';\n// Helper function to convert human-readable amounts to base units\nexport function toBaseUnits(amount: string, decimals: number): string {\n    // Remove any decimal point and count the decimal places\n    const [integerPart, decimalPart = ''] = amount.split('.');\n    const currentDecimals = decimalPart.length;\n\n    // Combine integer and decimal parts, removing the decimal point\n    let result = integerPart + decimalPart;\n\n    // Add zeros if you need more decimal places\n    if (currentDecimals < decimals) {\n        result = result + '0'.repeat(decimals - currentDecimals);\n    }\n    // Remove digits if you have too many decimal places\n    else if (currentDecimals > decimals) {\n        result = result.slice(0, result.length - (currentDecimals - decimals));\n    }\n\n    // Remove leading zeros\n    result = result.replace(/^0+/, '') || '0';\n\n    return result;\n}\n/**\n * Example: Approve a token for swapping\n */\nasync function executeApproval(tokenAddress: string, amount: string) {\n    try {\n        // Get token information using quote\n        console.log(\"Getting token information...\");\n        const tokenInfo = await client.dex.getQuote({\n            chainId: '8453',  // Base Chain\n            fromTokenAddress: tokenAddress,\n            toTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE', // Native token\n            amount: '1000000', // Use a reasonable amount for quote\n            slippage: '0.005'\n        });\n        const tokenDecimals = parseInt(tokenInfo.data[0].fromToken.decimal);\n        const rawAmount = toBaseUnits(amount, tokenDecimals);\n        console.log(`\\nApproval Details:`);\n        console.log(`--------------------`);\n        console.log(`Token: ${tokenInfo.data[0].fromToken.tokenSymbol}`);\n        console.log(`Amount: ${amount} ${tokenInfo.data[0].fromToken.tokenSymbol}`);\n        console.log(`Amount in base units: ${rawAmount}`);\n        // Execute the approval\n        console.log(\"\\nExecuting approval...\");\n        const result = await client.dex.executeApproval({\n            chainId: '8453',  // Base Chain\n            tokenContractAddress: tokenAddress,\n            approveAmount: rawAmount\n        });\n        if ('alreadyApproved' in result) {\n            console.log(\"\\nToken already approved for the requested amount!\");\n            return { success: true, alreadyApproved: true };\n        } else {\n            console.log(\"\\nApproval completed successfully!\");\n            console.log(\"Transaction Hash:\", result.transactionHash);\n            console.log(\"Explorer URL:\", result.explorerUrl);\n            return result;\n        }\n    } catch (error) {\n        if (error instanceof Error) {\n            console.error('Error executing approval:', error.message);\n        }\n        throw error;\n    }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n    // Example usage: ts-node approval.ts 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913 1000\n    const args = process.argv.slice(2);\n    if (args.length !== 2) {\n        console.log(\"Usage: ts-node approval.ts <tokenAddress> <amountToApprove>\");\n        console.log(\"\\nExamples:\");\n        console.log(\"  # Approve 1000 USDC\");\n        console.log(`  ts-node approval.ts 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913 1000`);\n        process.exit(1);\n    }\n    const [tokenAddress, amount] = args;\n    executeApproval(tokenAddress, amount)\n        .then(() => process.exit(0))\n        .catch((error) => {\n            console.error('Error:', error);\n            process.exit(1);\n        });\n}\nexport { executeApproval };\n```\n\n## 5.调用SDK执行兑换[#](#5.调用sdk执行兑换)\n\n创建兑换执行的文件：\n\n```typescript\n// swap.ts\nimport { client } from './DexClient';\n/**\n * Example: Execute a swap from ETH to USDC on Base chain\n */\nasync function executeSwap() {\n  try {\n    if (!process.env.EVM_PRIVATE_KEY) {\n      throw new Error('Missing EVM_PRIVATE_KEY in .env file');\n    }\n    // You can change this to any EVM chain\n    // For example, for Base, use chainId: '8453'\n    // For example, for baseSepolia, use chainId: '84532'\n    // You can also use SUI, use chainId: '784'\n    // When using another Chain, you need to change the fromTokenAddress and toTokenAddress to the correct addresses for that chain\n\n    const swapResult = await client.dex.executeSwap({\n      chainId: '8453', // Base chain ID\n      fromTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE', // Native ETH\n      toTokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base\n      amount: String(10 * 10 ** 14), // .0001 ETH\n      slippage: '0.005', // 0.5% slippage\n      userWalletAddress: process.env.EVM_WALLET_ADDRESS!\n    });\n    console.log('Swap executed successfully:');\n    console.log(JSON.stringify(swapResult, null, 2));\n\n    return swapResult;\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error('Error executing swap:', error.message);\n      // API errors include details in the message\n      if (error.message.includes('API Error:')) {\n        const match = error.message.match(/API Error: (.*)/);\n        if (match) console.error('API Error Details:', match[1]);\n      }\n    }\n    throw error;\n  }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n  executeSwap()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Error:', error);\n      process.exit(1);\n    });\n}\nexport { executeSwap };\n```\n\n## 6.附加的SDK功能[#](#6.附加的sdk功能)\n\nSDK提供了简化开发的附加方法： 获取代币对的报价\n\n```typescript\nconst quote = await client.dex.getQuote({\n    chainId: '8453',  // Base Chain\n    fromTokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC\n    toTokenAddress: '0x4200000000000000000000000000000000000006', // WETH\n    amount: '1000000',  // 1 USDC (in smallest units)\n    slippage: '0.005'     // 0.5%\n});\n```\n\n[\n\n在 Solana 链上兑换的高级用法\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-solana-advance-control)[\n\n在 Sui 链上搭建兑换应用\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-sui-quick-start)\n\n目录\n\n[方法1：API方法](#方法1：api方法)[1.设置环境](#1.设置环境)[2.检查授权额度](#2.检查授权额度)[3.检查授权交易参数并发起授权](#3.检查授权交易参数并发起授权)[4.请求询价接口，拿到询价数据](#4.请求询价接口，拿到询价数据)[5.请求兑换接口，发起交易](#5.请求兑换接口，发起交易)[6\\. 模拟交易](#6.-模拟交易)[7\\. 广播交易](#7.-广播交易)[8\\. 追踪交易](#8.-追踪交易)[9\\. 完整实现](#9.-完整实现)[10\\. MEV Protection](#10.-mev-protection)[方法2：SDK方法](#方法2：sdk方法)[1.安装SDK](#1.安装sdk)[2.设置环境](#2.设置环境)[3.初始化客户端](#3.初始化客户端)[4.调用SDK执行代币授权](#4.调用sdk执行代币授权)[5.调用SDK执行兑换](#5.调用sdk执行兑换)[6.附加的SDK功能](#6.附加的sdk功能)"
    },
    "在 Sui 链上搭建兑换应用#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n指南\n\n在 Sui 链上搭建兑换应用\n\n# 在 Sui 链上搭建兑换应用[#](#在-sui-链上搭建兑换应用)\n\n在Sui上使用OKX DEX构建兑换应用程序有两种方法：\n\n*   API 方法 - 直接调用 OKX DEX API\n*   SDK方法 - 使用 `@okx-dex/okx-dex-sdk`，简化了开发人员的体验\n\n本指南涵盖了这两种方法，以帮助你选择最适合你需求的方法。\n\n## 方法1：API方法[#](#方法1：api方法)\n\n在本指南中，我们将提供通过OKX DEX进行Sui代币兑换的用例。\n\n## 1\\. 设置环境[#](#1.-设置环境)\n\n导入必要的Node. js库并设置环境变量：\n\n```javascript\n// Required libraries\nimport { SuiWallet } from \"@okxweb3/coin-sui\";\nimport { getFullnodeUrl, SuiClient } from '@mysten/sui/client';\nimport { Transaction } from '@mysten/sui/transactions';\nimport cryptoJS from \"crypto-js\";\n// Install dependencies\n// npm i @okxweb3/coin-sui\n// npm i @mysten/sui\n// npm i crypto-js\n// Set up environment variables\nconst apiKey = 'your_api_key';\nconst secretKey = 'your_secret_key';\nconst apiPassphrase = 'your_passphrase';\nconst projectId = 'your_project_id';\nconst userAddress = 'your_sui_wallet_address';\nconst userPrivateKey = 'your_sui_wallet_private_key';\n// Constants\nconst SUI_CHAIN_ID = \"784\";\nconst DEFAULT_GAS_BUDGET = 50000000;\nconst MAX_RETRIES = 3;\n// Initialize Sui client\nconst wallet = new SuiWallet();\nconst client = new SuiClient({\n    url: getFullnodeUrl('mainnet')\n});\n// For Sui, you need to use the hexWithoutFlag format of your private key\n// You can convert your key using sui keytool:\n// sui keytool convert <your_sui_private_key>\n```\n\n## 2\\. 获取代币信息和兑换报价[#](#2.-获取代币信息和兑换报价)\n\n首先，创建一个实用函数来处理API身份验证标头：\n\n```javascript\nfunction getHeaders(timestamp, method, requestPath, queryString = \"\") {\n    if (!apiKey || !secretKey || !apiPassphrase || !projectId) {\n        throw new Error(\"Missing required environment variables\");\n    }\n    const stringToSign = timestamp + method + requestPath + queryString;\n    return {\n        \"Content-Type\": \"application/json\",\n        \"OK-ACCESS-KEY\": apiKey,\n        \"OK-ACCESS-SIGN\": cryptoJS.enc.Base64.stringify(\n            cryptoJS.HmacSHA256(stringToSign, secretKey)\n        ),\n        \"OK-ACCESS-TIMESTAMP\": timestamp,\n        \"OK-ACCESS-PASSPHRASE\": apiPassphrase,\n        \"OK-ACCESS-PROJECT\": projectId,\n    };\n}\n然后，创建一个函数来获取令牌信息：\nasync function getTokenInfo(fromTokenAddress, toTokenAddress) {\n    const timestamp = new Date().toISOString();\n    const requestPath = \"/api/v5/dex/aggregator/quote\";\n    const params = {\n        chainId: SUI_CHAIN_ID,\n        fromTokenAddress,\n        toTokenAddress,\n        amount: \"1000000\",\n        slippage: \"0.005\",// 0.5% slippage\n    };\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\n    const response = await fetch(\n        `https://web3.okx.com${requestPath}${queryString}`,\n        { method: \"GET\", headers }\n    );\n    if (!response.ok) {\n        throw new Error(`Failed to get quote: ${await response.text()}`);\n    }\n    const data = await response.json();\n    if (data.code !== \"0\" || !data.data?.[0]) {\n        throw new Error(\"Failed to get token information\");\n    }\n    const quoteData = data.data[0];\n    return {\n        fromToken: {\n            symbol: quoteData.fromToken.tokenSymbol,\n            decimals: parseInt(quoteData.fromToken.decimal),\n            price: quoteData.fromToken.tokenUnitPrice\n        },\n        toToken: {\n            symbol: quoteData.toToken.tokenSymbol,\n            decimals: parseInt(quoteData.toToken.decimal),\n            price: quoteData.toToken.tokenUnitPrice\n        }\n    };\n}\n```\n\n创建一个函数将人类可读的数量转换为基本单位：\n\n```javascript\nfunction convertAmount(amount, decimals) {\n    try {\n        if (!amount || isNaN(parseFloat(amount))) {\n            throw new Error(\"Invalid amount\");\n        }\n        const value = parseFloat(amount);\n        if (value <= 0) {\n            throw new Error(\"Amount must be greater than 0\");\n        }\n        return (BigInt(Math.floor(value * Math.pow(10, decimals)))).toString();\n    } catch (err) {\n        console.error(\"Amount conversion error:\", err);\n        throw new Error(\"Invalid amount format\");\n    }\n}\n```\n\n## 3\\. 处理和签署交易[#](#3.-处理和签署交易)\n\n3.1 Define swap parameters\n\n```typescript\nconst swapParams = {\n      chainId: chainId,\n      fromTokenAddress,\n      toTokenAddress,\n      amount,\n      userWalletAddress: userAddress,\n      slippage\n};\n```\n\n3.2 Request swap transaction data\n\n```typescript\n/**\n * Get swap transaction data from DEX API\n * @param fromTokenAddress - Source token address\n * @param toTokenAddress - Destination token address\n * @param amount - Amount to swap\n * @param userAddress - User wallet address\n * @param slippage - Maximum slippage (e.g., \"0.5\" for 0.5%)\n * @returns Swap transaction data\n */\nasync function getSwapTransaction(\n  fromTokenAddress: string,\n  toTokenAddress: string,\n  amount: string,\n  userAddress: string,\n  slippage: string = '0.5'\n): Promise<any> {\n  try {\n    const path = 'dex/aggregator/swap';\n    const url = `${baseUrl}${path}`;\n\n    const params = {\n      chainId: chainId,\n      fromTokenAddress,\n      toTokenAddress,\n      amount,\n      userWalletAddress: userAddress,\n      slippage\n    };\n\n    // Prepare authentication\n    const timestamp = new Date().toISOString();\n    const requestPath = `/api/v5/${path}`;\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n    const response = await axios.get(url, { params, headers });\n\n    if (response.data.code === '0') {\n      return response.data.data[0];\n    } else {\n      throw new Error(`API Error: ${response.data.msg || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.error('Failed to get swap transaction data:', (error as Error).message);\n    throw error;\n  }\n}\n```\n\n## 4\\. 模拟交易[#](#4.-模拟交易)\n\n在执行实际兑换之前，务必模拟交易以确保其成功并识别任何潜在问题：\n\n此功能使用 `交易上链 API`。此 API 仅供我们的白名单客户使用。如您感兴趣，请联系我们 [dexapi@okx.com](mailto:dexapi@okx.com)。\n\n```javascript\nasync function simulateTransaction(txData) {\n    try {\n        if (!txData) {\n            throw new Error('Invalid transaction data format');\n        }\n\n        const params = {\n            chainIndex: SUI_CHAIN_ID,\n            txData: txData,\n            includeDebug: true\n        };\n\n        const timestamp = new Date().toISOString();\n        const requestPath = \"/api/v5/dex/pre-transaction/simulate\";\n        const requestBody = JSON.stringify(params);\n        const headers = getHeaders(timestamp, \"POST\", requestPath, \"\", requestBody);\n\n        console.log('Simulating transaction...');\n        const response = await fetch(\n            `https://web3.okx.com${requestPath}`,\n            {\n                method: 'POST',\n                headers,\n                body: requestBody\n            }\n        );\n\n        const data = await response.json();\n        if (data.code !== \"0\") {\n            throw new Error(`Simulation failed: ${data.msg || \"Unknown simulation error\"}`);\n        }\n\n        const simulationResult = data.data[0];\n        \n        // Check simulation success\n        if (simulationResult.success === false) {\n            console.error('Transaction simulation failed:', simulationResult.error);\n            throw new Error(`Transaction would fail: ${simulationResult.error}`);\n        }\n\n        console.log('Transaction simulation successful');\n        console.log(`Estimated gas used: ${simulationResult.gasUsed || 'N/A'}`);\n        \n        if (simulationResult.logs) {\n            console.log('Simulation logs:', simulationResult.logs);\n        }\n\n        return simulationResult;\n    } catch (error) {\n        console.error(\"Error simulating transaction:\", error);\n        throw error;\n    }\n}\n```\n\n## 5\\. 执行交易[#](#5.-执行交易)\n\n最后，执行签名交易：\n\n```javascript\nasync function executeSwap(txData, privateKey) {\n    // Create transaction block\n    const txBlock = Transaction.from(txData);\n    txBlock.setSender(normalizedWalletAddress);\n    // Set gas parameters\n    const referenceGasPrice = await client.getReferenceGasPrice();\n    txBlock.setGasPrice(BigInt(referenceGasPrice));\n    txBlock.setGasBudget(BigInt(DEFAULT_GAS_BUDGET));\n    // Build and sign transaction\n    const builtTx = await txBlock.build({ client });\n    const txBytes = Buffer.from(builtTx).toString('base64');\n    const signedTx = await wallet.signTransaction({\n        privateKey,\n        data: {\n            type: 'raw',\n            data: txBytes\n        }\n    });\n    if (!signedTx?.signature) {\n        throw new Error(\"Failed to sign transaction\");\n    }\n    return { builtTx, signature: signedTx.signature };\n}\n```\n\n然后，使用 RPC 方法调用发送交易\n\n使用 RPC:\n\n```javascript\nasync function sendTransaction(builtTx, signature) {\n    // Execute transaction\n    const result = await client.executeTransactionBlock({\n        transactionBlock: builtTx,\n        signature: [signature],\n        options: {\n            showEffects: true,\n            showEvents: true,\n        }\n    });\n    // Wait for confirmation\n    const confirmation = await client.waitForTransaction({\n        digest: result.digest,\n        options: {\n            showEffects: true,\n            showEvents: true,\n        }\n    });\n    console.log(\"\\nSwap completed successfully!\");\n    console.log(\"Transaction ID:\", result.digest);\n    console.log(\"Explorer URL:\", `https://suiscan.xyz/mainnet/tx/${result.digest}`);\n    return result.digest;\n}\n```\n\n## 6\\. 跟踪交易[#](#6.-跟踪交易)\n\n使用 SWAP API 跟踪交易：\n\nSWAP API 交易跟踪使用 `/dex/aggregator/history` 端点提供全面的交换执行详情。它提供特定于代币的信息（符号、金额）、已支付的费用以及详细的区块链数据。当您需要获取包含代币级详细信息的完整交换洞察时，请使用此功能。\n\n```javascript\nasync function trackTransactionWithSwapAPI(txHash) {\n    try {\n        const path = 'dex/aggregator/history';\n        const url = `${baseUrl}${path}`;\n\n        const params = {\n            chainId: SUI_CHAIN_ID,\n            txHash: txHash,\n            isFromMyProject: 'false'\n        };\n\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const queryString = \"?\" + new URLSearchParams(params).toString();\n        const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n        console.log('Fetching transaction status...');\n        const response = await fetch(`${url}${queryString}`, { headers });\n        const data = await response.json();\n\n        if (!data) {\n            throw new Error('No response data received from API');\n        }\n\n        if (data.code !== '0') {\n            throw new Error(`API Error: ${data.msg || 'Unknown error'}`);\n        }\n\n        if (!data.data || !Array.isArray(data.data) || data.data.length === 0) {\n            console.log('Transaction not found in history yet, might be too recent');\n            return { status: 'pending', details: null };\n        }\n\n        const txData = data.data[0];\n        if (!txData) {\n            console.log('Transaction data not available yet');\n            return { status: 'pending', details: null };\n        }\n\n        const status = txData.status;\n        console.log(`Transaction status: ${status}`);\n\n        if (status === 'pending') {\n            console.log(`Transaction is still pending: ${txHash}`);\n            return { status: 'pending', details: txData };\n        } else if (status === 'success') {\n            console.log(`Transaction successful!`);\n            console.log(`From: ${txData.fromTokenDetails.symbol} - Amount: ${txData.fromTokenDetails.amount}`);\n            console.log(`To: ${txData.toTokenDetails.symbol} - Amount: ${txData.toTokenDetails.amount}`);\n            console.log(`Transaction Fee: ${txData.txFee}`);\n            console.log(`Explorer URL: https://suiscan.xyz/mainnet/tx/${txHash}`);\n            return { status: 'success', details: txData };\n        } else if (status === 'fail') {\n            const errorMsg = txData.errorMsg || 'Unknown reason';\n            console.error(`Transaction failed: ${errorMsg}`);\n            return { status: 'failure', details: txData, error: errorMsg };\n        }\n\n        return { status: 'unknown', details: txData };\n    } catch (error) {\n        console.error('Failed to track transaction status:', error.message);\n        return { status: 'pending', details: null, error: error.message };\n    }\n}\n```\n\n## 7\\. 完整实现[#](#7.-完整实现)\n\n这是一个完整的实现示例：\n\n```javascript\n// swap.ts\nimport { SuiWallet } from \"@okxweb3/coin-sui\";\nimport { getFullnodeUrl, SuiClient } from '@mysten/sui/client';\nimport { Transaction } from '@mysten/sui/transactions';\nimport cryptoJS from \"crypto-js\";\nimport dotenv from 'dotenv';\ndotenv.config();\n\n// Environment variables\nconst apiKey = process.env.OKX_API_KEY;\nconst secretKey = process.env.OKX_SECRET_KEY;\nconst apiPassphrase = process.env.OKX_API_PASSPHRASE;\nconst projectId = process.env.OKX_PROJECT_ID;\nconst userAddress = process.env.WALLET_ADDRESS;\nconst userPrivateKey = process.env.PRIVATE_KEY;\n\n// Constants\nconst SUI_CHAIN_ID = \"784\";\nconst DEFAULT_GAS_BUDGET = 50000000;\nconst MAX_RETRIES = 3;\n\n// Initialize clients\nconst wallet = new SuiWallet();\nconst client = new SuiClient({\n    url: getFullnodeUrl('mainnet')\n});\n\n// Normalize wallet address\nconst normalizedWalletAddress = userAddress;\n\nfunction getHeaders(timestamp: string, method: string, requestPath: string, queryString: string = \"\", requestBody: string = \"\") {\n    if (!apiKey || !secretKey || !apiPassphrase || !projectId) {\n        throw new Error(\"Missing required environment variables\");\n    }\n    const stringToSign = timestamp + method + requestPath + queryString + requestBody;\n    return {\n        \"Content-Type\": \"application/json\",\n        \"OK-ACCESS-KEY\": apiKey,\n        \"OK-ACCESS-SIGN\": cryptoJS.enc.Base64.stringify(\n            cryptoJS.HmacSHA256(stringToSign, secretKey)\n        ),\n        \"OK-ACCESS-TIMESTAMP\": timestamp,\n        \"OK-ACCESS-PASSPHRASE\": apiPassphrase,\n        \"OK-ACCESS-PROJECT\": projectId,\n    };\n}\nasync function getTokenInfo(fromTokenAddress: string, toTokenAddress: string) {\n    const timestamp = new Date().toISOString();\n    const requestPath = \"/api/v5/dex/aggregator/quote\";\n    const params = {\n        chainId: SUI_CHAIN_ID,\n        fromTokenAddress,\n        toTokenAddress,\n        amount: \"1000000\",\n        slippage: \"0.005\",// 0.5% slippage\n    };\n    const queryString = \"?\" + new URLSearchParams(params).toString();\n    const headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\n    const response = await fetch(\n        `https://web3.okx.com${requestPath}${queryString}`,\n        { method: \"GET\", headers }\n    );\n    if (!response.ok) {\n        throw new Error(`Failed to get quote: ${await response.text()}`);\n    }\n    const data = await response.json();\n    if (data.code !== \"0\" || !data.data?.[0]) {\n        throw new Error(\"Failed to get token information\");\n    }\n    const quoteData = data.data[0];\n    return {\n        fromToken: {\n            symbol: quoteData.fromToken.tokenSymbol,\n            decimals: parseInt(quoteData.fromToken.decimal),\n            price: quoteData.fromToken.tokenUnitPrice\n        },\n        toToken: {\n            symbol: quoteData.toToken.tokenSymbol,\n            decimals: parseInt(quoteData.toToken.decimal),\n            price: quoteData.toToken.tokenUnitPrice\n        }\n    };\n}\nfunction convertAmount(amount: string | number, decimals: number) {\n    try {\n        if (!amount || isNaN(parseFloat(amount.toString()))) {\n            throw new Error(\"Invalid amount\");\n        }\n        const value = parseFloat(amount.toString());\n        if (value <= 0) {\n            throw new Error(\"Amount must be greater than 0\");\n        }\n        return (BigInt(Math.floor(value * Math.pow(10, decimals)))).toString();\n    } catch (err) {\n        console.error(\"Amount conversion error:\", err);\n        throw new Error(\"Invalid amount format\");\n    }\n}\n\nasync function trackTransactionWithSwapAPI(txHash: string) {\n    try {\n        const path = 'dex/aggregator/history';\n        const url = `https://web3.okx.com/api/v5/${path}`;\n\n        const params = {\n            chainId: SUI_CHAIN_ID,\n            txHash: txHash,\n            isFromMyProject: 'false'\n        };\n\n        const timestamp = new Date().toISOString();\n        const requestPath = `/api/v5/${path}`;\n        const queryString = \"?\" + new URLSearchParams(params).toString();\n        const headers = getHeaders(timestamp, 'GET', requestPath, queryString);\n\n        const response = await fetch(`${url}${queryString}`, { headers });\n        const data = await response.json();\n\n        if (data.code !== '0') {\n            throw new Error(`API Error: ${data.msg || 'Unknown error'}`);\n        }\n\n        return data.data?.[0] || { status: 'pending' };\n    } catch (error) {\n        console.error('Failed to track transaction:', error);\n        return { status: 'error', error: error instanceof Error ? error.message : 'Unknown error' };\n    }\n}\n\n\nasync function main() {\n    try {\n        const args = process.argv.slice(2);\n        if (args.length < 3) {\n            console.log(\"Usage: ts-node swap.ts <amount> <fromTokenAddress> <toTokenAddress>\");\n            console.log(\"Example: ts-node swap.ts 1.5 0x2::sui::SUI 0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC\");\n            process.exit(1);\n        }\n\n        const [amount, fromTokenAddress, toTokenAddress] = args;\n        if (!userPrivateKey || !userAddress) {\n            throw new Error(\"Private key or user address not found\");\n        }\n\n        // Get token information\n        console.log(\"Getting token information...\");\n        const tokenInfo = await getTokenInfo(fromTokenAddress, toTokenAddress);\n        console.log(`From: ${tokenInfo.fromToken.symbol} (${tokenInfo.fromToken.decimals} decimals)`);\n        console.log(`To: ${tokenInfo.toToken.symbol} (${tokenInfo.toToken.decimals} decimals)`);\n\n        // Convert amount using fetched decimals\n        const rawAmount = convertAmount(amount, tokenInfo.fromToken.decimals);\n        console.log(`Amount in ${tokenInfo.fromToken.symbol} base units:`, rawAmount);\n\n        // Get swap quote\n        const quoteParams = {\n            chainId: SUI_CHAIN_ID,\n            amount: rawAmount,\n            fromTokenAddress,\n            toTokenAddress,\n            slippage: \"0.005\",// 0.5% slippage\n            userWalletAddress: normalizedWalletAddress || \"\",\n        };\n\n        // Get swap data\n        const timestamp = new Date().toISOString();\n        const requestPath = \"/api/v5/dex/aggregator/swap\";\n        const queryString = \"?\" + new URLSearchParams(quoteParams).toString();\n        const headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\n\n        console.log(\"Requesting swap quote...\");\n        const response = await fetch(\n            `https://web3.okx.com${requestPath}${queryString}`,\n            { method: \"GET\", headers }\n        );\n        const data = await response.json();\n\n        if (data.code !== \"0\") {\n            throw new Error(`API Error: ${data.msg}`);\n        }\n\n        const swapData = data.data[0];\n\n        // Show estimated output and price impact\n        const outputAmount = parseFloat(swapData.routerResult.toTokenAmount) / Math.pow(10, tokenInfo.toToken.decimals);\n        console.log(\"\\nSwap Quote:\");\n        console.log(`Input: ${amount} ${tokenInfo.fromToken.symbol} ($${(parseFloat(amount) * parseFloat(tokenInfo.fromToken.price)).toFixed(2)})`);\n        console.log(`Output: ${outputAmount.toFixed(tokenInfo.toToken.decimals)} ${tokenInfo.toToken.symbol} ($${(outputAmount * parseFloat(tokenInfo.toToken.price)).toFixed(2)})`);\n\n        if (swapData.priceImpactPercentage) {\n            console.log(`Price Impact: ${swapData.priceImpactPercentage}%`);\n        }\n\n        console.log(\"\\nExecuting swap transaction...\");\n        let retryCount = 0;\n        while (retryCount < MAX_RETRIES) {\n            try {\n                // Create transaction block\n                const txBlock = Transaction.from(swapData.tx.data);\n                if (!normalizedWalletAddress) {\n                    throw new Error(\"Wallet address is not defined\");\n                }\n                txBlock.setSender(normalizedWalletAddress);\n                // Set gas parameters\n                const referenceGasPrice = await client.getReferenceGasPrice();\n                txBlock.setGasPrice(BigInt(referenceGasPrice));\n                txBlock.setGasBudget(BigInt(DEFAULT_GAS_BUDGET));\n                // Build and sign transaction\n                const builtTx = await txBlock.build({ client });\n                const txBytes = Buffer.from(builtTx).toString('base64');\n                const signedTx = await wallet.signTransaction({\n                    privateKey: userPrivateKey,\n                    data: {\n                        type: 'raw',\n                        data: txBytes\n                    }\n                });\n                if (!signedTx?.signature) {\n                    throw new Error(\"Failed to sign transaction\");\n                }\n\n                // Execute transaction\n                const result = await client.executeTransactionBlock({\n                    transactionBlock: builtTx,\n                    signature: [signedTx.signature],\n                    options: {\n                        showEffects: true,\n                        showEvents: true,\n                    }\n                });\n\n                // Wait for confirmation\n                const confirmation = await client.waitForTransaction({\n                    digest: result.digest,\n                    options: {\n                        showEffects: true,\n                        showEvents: true,\n                    }\n                });\n\n                console.log(\"\\nSwap completed successfully!\");\n                console.log(\"Transaction ID:\", result.digest);\n                console.log(\"Explorer URL:\", `https://suiscan.xyz/mainnet/tx/${result.digest}`);\n\n                // Track transaction\n                const txStatus = await trackTransactionWithSwapAPI(result.digest);\n                console.log(\"Transaction Status:\", txStatus);\n\n                process.exit(0);\n            } catch (error) {\n                console.error(`Attempt ${retryCount + 1} failed:`, error);\n                retryCount++;\n                if (retryCount === MAX_RETRIES) {\n                    throw error;\n                }\n                await new Promise(resolve => setTimeout(resolve, 2000 * retryCount));\n            }\n        }\n    } catch (error) {\n        console.error(\"Error:\", error instanceof Error ? error.message : \"Unknown error\");\n        process.exit(1);\n    }\n}\n\nif (require.main === module) {\n    main();\n}\n```\n\n## 方法2：SDK方法[#](#方法2：sdk方法)\n\nOKX DEX SDK 提供了更简单的开发人员体验，同时保留了API方法的所有功能。SDK为你处理许多实现细节，包括重试逻辑、错误处理和交易管理。\n\n## 1\\. 安装SDK[#](#1.-安装sdk)\n\n```javascript\nnpm install @okx-dex/okx-dex-sdk\n# or\nyarn add @okx-dex/okx-dex-sdk\n# or\npnpm add @okx-dex/okx-dex-sdk\n```\n\n## 2\\. 设置环境[#](#2.-设置环境)\n\n使用你的API凭据和钱包信息创建一个. env文件：\n\n```javascript\n# OKX API Credentials\nOKX_API_KEY=your_api_key\nOKX_SECRET_KEY=your_secret_key\nOKX_API_PASSPHRASE=your_passphrase\nOKX_PROJECT_ID=your_project_id\n# Sui Configuration\nSUI_WALLET_ADDRESS=your_sui_wallet_address\nSUI_PRIVATE_KEY=your_sui_private_key\n```\n\n请记住，您需要使用 SUI 私钥的 hexWithoutFlag 格式，您可以使用 SUI CLI 获取该格式：\n\n```javascript\nsui keytool convert <your_sui_private_key>\n```\n\n## 3\\. 初始化客户端[#](#3.-初始化客户端)\n\n为你的DEX客户端创建一个文件（例如，DexClient. ts）：\n\n```javascript\n// DexClient.ts\nimport { OKXDexClient } from '@okx-dex/okx-dex-sdk';\nimport 'dotenv/config';\n\n// Validate environment variables\nconst requiredEnvVars = [\n    'OKX_API_KEY',\n    'OKX_SECRET_KEY',\n    'OKX_API_PASSPHRASE',\n    'OKX_PROJECT_ID',\n    'SUI_WALLET_ADDRESS',\n    'SUI_PRIVATE_KEY'\n];\n\nfor (const envVar of requiredEnvVars) {\n    if (!process.env[envVar]) {\n        throw new Error(`Missing required environment variable: ${envVar}`);\n    }\n}\n\n// Initialize the client\nexport const client = new OKXDexClient({\n    apiKey: process.env.OKX_API_KEY!,\n    secretKey: process.env.OKX_SECRET_KEY!,\n    apiPassphrase: process.env.OKX_API_PASSPHRASE!,\n    projectId: process.env.OKX_PROJECT_ID!,\n    sui: {\n        privateKey: process.env.SUI_PRIVATE_KEY!,\n        walletAddress: process.env.SUI_WALLET_ADDRESS!,\n        connection: {\n            rpcUrl: 'https://sui-mainnet.blockvision.org'\n        }\n    }\n});\n```\n\n## 4\\. 创建代币助手（可选）[#](#4.-创建代币助手（可选）)\n\n你可以创建一个代币列表助手以便于参考：\n\n```javascript\n// Common tokens on Sui mainnet\nexport const TOKENS = {\n    SUI: \"0x2::sui::SUI\",\n    USDC: \"0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC\"\n} as const;\n```\n\n## 5\\. 调用SDK执行兑换[#](#5.-调用sdk执行兑换)\n\n创建兑换执行的文件：\n\n```javascript\n// swap.ts\nimport { client } from './DexClient';\nimport { TOKENS } from './Tokens'; // Optional, if you created the token helper\n/**\n * Example: Execute a swap from SUI to USDC\n */\nasync function executeSwap() {\n  try {\n    if (!process.env.SUI_PRIVATE_KEY) {\n      throw new Error('Missing SUI_PRIVATE_KEY in .env file');\n    }\n\n    // First, get token information using a quote\n    console.log(\"Getting token information...\");\n    const fromTokenAddress = TOKENS.SUI; // Or use directly: \"0x2::sui::SUI\"\n    const toTokenAddress = TOKENS.USDC; // Or use directly: \"0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC\"\n\n    const quote = await client.dex.getQuote({\n        chainId: '784', // Sui chain ID\n        fromTokenAddress,\n        toTokenAddress,\n        amount: '1000000', // Small amount for quote\n        slippage: '0.005' // 0.5% slippage\n    });\n\n    const tokenInfo = {\n        fromToken: {\n            symbol: quote.data[0].fromToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].fromToken.decimal),\n            price: quote.data[0].fromToken.tokenUnitPrice\n        },\n        toToken: {\n            symbol: quote.data[0].toToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].toToken.decimal),\n            price: quote.data[0].toToken.tokenUnitPrice\n        }\n    };\n\n    // Convert amount to base units\n    const humanReadableAmount = 1.5; // 1.5 SUI\n    const rawAmount = (humanReadableAmount * Math.pow(10, tokenInfo.fromToken.decimals)).toString();\n\n    console.log(\"\\nSwap Details:\");\n    console.log(\"--------------------\");\n    console.log(`From: ${tokenInfo.fromToken.symbol}`);\n    console.log(`To: ${tokenInfo.toToken.symbol}`);\n    console.log(`Amount: ${humanReadableAmount} ${tokenInfo.fromToken.symbol}`);\n    console.log(`Amount in base units: ${rawAmount}`);\n    console.log(`Approximate USD value: $${(humanReadableAmount * parseFloat(tokenInfo.fromToken.price)).toFixed(2)}`);\n\n    // Execute the swap\n    console.log(\"\\nExecuting swap...\");\n    const swapResult = await client.dex.executeSwap({\n      chainId: '784', // Sui chain ID\n      fromTokenAddress,\n      toTokenAddress,\n      amount: rawAmount,\n      slippage: '0.005', // 0.5% slippage\n      userWalletAddress: process.env.SUI_WALLET_ADDRESS!\n    });\n\n    console.log('Swap executed successfully:');\n    console.log(\"\\nTransaction ID:\", swapResult.transactionId);\n    console.log(\"Explorer URL:\", swapResult.explorerUrl);\n\n    if (swapResult.details) {\n        console.log(\"\\nDetails:\");\n        console.log(`Input: ${swapResult.details.fromToken.amount} ${swapResult.details.fromToken.symbol}`);\n        console.log(`Output: ${swapResult.details.toToken.amount} ${swapResult.details.toToken.symbol}`);\n        if (swapResult.details.priceImpact) {\n            console.log(`Price Impact: ${swapResult.details.priceImpact}%`);\n        }\n    }\n\n    return swapResult;\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error('Error executing swap:', error.message);\n      // API errors include details in the message\n      if (error.message.includes('API Error:')) {\n        const match = error.message.match(/API Error: (.*)/);\n        if (match) console.error('API Error Details:', match[1]);\n      }\n    }\n    throw error;\n  }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n  executeSwap()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Error:', error);\n      process.exit(1);\n    });\n}\nexport { executeSwap };\n\n```\n\n## 6\\. 附加SDK功能[#](#6.-附加sdk功能)\n\nSDK提供了简化开发的附加方法： 获取代币对的报价\n\n```javascript\nconst quote = await client.dex.getQuote({\n    chainId: '784',  // Sui\n    fromTokenAddress: '0x2::sui::SUI', // SUI\n    toTokenAddress: '0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC', // USDC\n    amount: '100000000',  // In base units\n    slippage: '0.005'     // 0.5% slippage\n});\n```\n\n[\n\n在 EVM 链上搭建兑换应用\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-quick-start)[\n\n在 Ton 链上搭建兑换应用\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-ton-quick-start)\n\n目录\n\n[方法1：API方法](#方法1：api方法)[1\\. 设置环境](#1.-设置环境)[2\\. 获取代币信息和兑换报价](#2.-获取代币信息和兑换报价)[3\\. 处理和签署交易](#3.-处理和签署交易)[4\\. 模拟交易](#4.-模拟交易)[5\\. 执行交易](#5.-执行交易)[6\\. 跟踪交易](#6.-跟踪交易)[7\\. 完整实现](#7.-完整实现)[方法2：SDK方法](#方法2：sdk方法)[1\\. 安装SDK](#1.-安装sdk)[2\\. 设置环境](#2.-设置环境)[3\\. 初始化客户端](#3.-初始化客户端)[4\\. 创建代币助手（可选）](#4.-创建代币助手（可选）)[5\\. 调用SDK执行兑换](#5.-调用sdk执行兑换)[6\\. 附加SDK功能](#6.-附加sdk功能)"
    },
    "在 Ton 链上搭建兑换应用#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n指南\n\n在 Ton 链上搭建兑换应用\n\n# 在 Ton 链上搭建兑换应用[#](#在-ton-链上搭建兑换应用)\n\n在本指南中，我们将用一个示例来展示如何通过欧易 DEX 提供的 API 在 Ton 上用 Ton 兑换 JETTON，这个过程中的步骤包括：\n\n1.  设置你的环境\n2.  请求询价接口，获取询价数据\n3.  请求兑换接口，发起交易\n\n## 1\\. 设置你的环境[#](#1.-设置你的环境)\n\n```bash\n# --------------------- npm package ---------------------\nnpm install @ton/ton @ton/crypto @ton/core buffer @orbs-network\n```\n\n```js\nconst cryptoJS = require('crypto-js'); // Import encryption modules for subsequent encryption calculations\nconst { TonClient, WalletContractV4, internal } = require(\"@ton/ton\");\nconst { toNano, Cell } = require(\"@ton/core\");\nconst { mnemonicToPrivateKey } = require(\"@ton/crypto\");\nconst { getHttpEndpoint } = require(\"@orbs-network/ton-access\");\n// --------------------- environment variable ---------------------\nconst apiBaseUrl = 'https://web3.okx.com/api/v5/dex/aggregator';\nconst chainId = '607';\n// Native token contract address\nconst fromTokenAddress = 'EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c';\n// JETTON token contract address\nconst toTokenAddress = 'EQAQXlWJvGbbFfE8F3oS8s87lIgdovS455IsWFaRdmJetTon';\n// your wallet address\nconst user = 'UQDoI2kiSNQZxxxxxxxxxxxx6lM2ZSxKkEw3k1'\nconst fromAmount = '1000000'\n// user wallet private key\nconst privateKey = 'xxxxx';\n// open api Secret key\nconst secretkey = 'xxxxx'\n// Get the current time\nconst date = new Date();\n\n// --------------------- util function ---------------------\nfunction getAggregatorRequestUrl(methodName, queryParams) {\n    return apiBaseUrl + methodName + '?' + (new URLSearchParams(queryParams)).toString();\n}\n\n// Check https://web3.okx.com/zh-hans/web3/build/docs/waas/rest-authentication for api-key\n\nconst headersParams = {\n    'Content-Type': 'application/json',\n    // The api Key obtained from the previous application\n    'OK-ACCESS-KEY': 'xxxxx',\n    'OK-ACCESS-SIGN': cryptoJS.enc.Base64.stringify(\n    // The field order of headersParams should be consistent with the order of quoteParams.\n    // example : quote  ==>   cryptoJS.HmacSHA256(date.toISOString() + 'GET' + '/api/v5/dex/aggregator/quote?amount=1000000&chainIndex=607&toTokenAddress=EQAQXlWJvGbbFfE8F3oS8s87lIgdovS455IsWFaRdmJetTon&fromTokenAddress=EQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c', secretKey)\n        cryptoJS.HmacSHA256(date.toISOString() + 'GET' + '/api/v5/dex/aggregator/xxx/xxx/xxx', secretKey)\n    ),\n    // Convert the current time to the desired format\n    'OK-ACCESS-TIMESTAMP': date.toISOString(),\n    // The password created when applying for the key\n    'OK-ACCESS-PASSPHRASE': 'xxxxxxx',\n};\n```\n\n## 2\\. 请求询价接口，拿到询价数据[#](#2.-请求询价接口，拿到询价数据)\n\n### 2.1 定义询价参数[#](#2.1-定义询价参数)\n\n*   接下来，定义询价参数，获取询价的基础信息和路径列表信息。\n\n```js\nconst quoteParams = {\n  amount: fromAmount,\n  chainId: chainId,\n  toTokenAddress: toTokenAddress,\n  fromTokenAddress: fromTokenAddress,\n};\n```\n\n### 2.2 定义辅助函数[#](#2.2-定义辅助函数)\n\n*   定义一个辅助函数，用于与 DEX API 进行交互。\n\n```js\nconst getQuote = async () => {\n  const apiRequestUrl = getAggregatorRequestUrl('/quote', quoteParams);\n  return fetch(apiRequestUrl, {\n    method: 'get',\n    headers: headersParams,\n  })\n    .then((res) => res.json())\n    .then((res) => {\n      return res;\n    });\n};\n```\n\n## 3\\. 请求兑换接口，发起交易[#](#3.-请求兑换接口，发起交易)\n\n### 3.1 定义兑换参数[#](#3.1-定义兑换参数)\n\n*   接下来，定义参数，并获取兑换的 tx 信息。\n\n```js\nconst swapParams = {\n  chainId: 1,\n  fromTokenAddress: fromTokenAddress,\n  toTokenAddress: toTokenAddress,\n  amount: '1000000',\n  slippage: '0.03', 3% slippage\n  userWalletAddress: user\n};\n```\n\n### 3.2 定义辅助函数[#](#3.2-定义辅助函数)\n\n定义一个辅助函数，用于与 DEX 批准交易 API 进行交互。\n\n```js\nconst getSwapData = async () => {\n  const apiRequestUrl = getAggregatorRequestUrl('/swap', swapParams);\n  return fetch(apiRequestUrl, {\n    method: 'get',\n    headers: headersParams,\n  })\n    .then((res) => res.json())\n    .then((res) => {\n      return res;\n    });\n};\n```\n\n### 3.3 请求兑换接口拿到 tx 信息，发起上链交易[#](#3.3-请求兑换接口拿到-tx-信息，发起上链交易)\n\n```js\nlet tx = {\n          \"data\": \"te6cckEBBAEAwAABsA+KfqUAALgW1FkYQkBfXhAIAK3+NxydEq8Qc4csyQ7botOnBqxp3L54Fn7Zof9EjDx5ADoI2kiSNQZdnOIVsRSLrVMtiBySHg0Lt6lM2ZSxKkEwyC592wEBAZ8RMwAAAvrwgIALyzu3/eo7h8wFCa+0XsOg6z0IG/43fUuMnumWS8xS91AD0F/w35CTWUxTWRjefoV+400KRA2jX51X4ezIgmUUY/0AX5sDCAIBAQwDABgAAAABAAAAAAAAA+cKUcDO\",\n          \"from\": \"UQDoI2kiSNQZdnOIVsRSLrVMtiBySHg0Lt6lM2ZSxKkEw3k1\",\n          \"gas\": \"80234000\",\n          \"gasPrice\": \"5000\",\n          \"maxPriorityFeePerGas\": \"\",\n          \"minReceiveAmount\": \"25062412\",\n          \"to\": \"UQBXp1W7_UJWvsBrbaO8s-9i8O53s7hNNeZ0XqEEz12i0oDS\",\n          \"value\": \"440000000\"\n}\n// This is the response of the /swap endpoint\n\nasync function sendTx() {\n\n    const endpoint = await getHttpEndpoint();\n    const client = new TonClient({ endpoint });\n\n    const mnemonic = ['range', 'xxxxxx']; //   Your mnemonic words  Decimal conversion\n    const keyPair = await mnemonicToPrivateKey(mnemonic);\n\n    const wallet = WalletContractV4.create({workchain: 0, publicKey: keyPair.publicKey});\n\n    const contract = client.open(wallet)\n\n\n    let seqno = await contract.getSeqno();\n    const body = Cell.fromBase64(tx.data);\n    const value = tx.value / Math.pow(10, 9); // Decimal conversion\n    const to = tx.to;\n\n    await contract.sendTransfer({\n        seqno,\n        secretKey: keyPair.secretKey,\n        messages: [internal({\n            value: toNano(value),\n            to,\n            body: body,\n        })]\n    });\n}\n```\n\n[\n\n在 Sui 链上搭建兑换应用\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-sui-quick-start)[\n\n介绍\n\n](/zh-hans/build/dev-docs/dex-api/dex-swap-api-introduction)\n\n目录\n\n[1\\. 设置你的环境](#1.-设置你的环境)[2\\. 请求询价接口，拿到询价数据](#2.-请求询价接口，拿到询价数据)[3\\. 请求兑换接口，发起交易](#3.-请求兑换接口，发起交易)"
    },
    "介绍#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n兑换 API\n\n介绍\n\n# 介绍[#](#介绍)\n\n欧易 DEX 聚合各去中心化交易所 (例如 Uniswap、Curve、Balancer 等) 的流动性来源，并能够将单笔交易拆分到多个 DEX，通过高效的路由为用户提供最优价格。\n\n欧易 DEX 询价与交易流程\n\n欧易 DEX 将综合计算价格、滑点和交易成本，并通过智能订单拆分算法，基于 DEX 和 PMM 报价的综合比较，为用户选择最佳报价：\n\n欧易 DEX 兑换交易流程\n\n1.  首先通过 /supported/chain 获取到可以支持的链信息。\n2.  通过 /aggregator/all-tokens 获取到可以支持的代币信息。\n3.  通过支持的链及代币信息构造请求 /quote 数据进行询价。\n4.  询价后获取用户对 OKX DEX router 的授权，对其钱包资产进行操作。\n5.  通过 /approve-transaction 获取授权。\n6.  通过 /swap 构造並获取兑换所需的交易数据\n7.  将/swap 返回的交易数据广播上链。\n\n[\n\n在 Ton 链上搭建兑换应用\n\n](/zh-hans/build/dev-docs/dex-api/dex-use-swap-ton-quick-start)[\n\nAPI 参考\n\n](/zh-hans/build/dev-docs/dex-api/dex-api-reference)"
    },
    "API 参考#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n兑换 API\n\nAPI 参考\n\n# API 参考[#](#api-参考)\n\n[\n\n获取支持的链\n\n获取欧易 DEX 聚合器协议单链支持兑换的链列表\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-get-aggregator-supported-chains)[\n\n获取币种列表\n\n获取欧易 DEX 聚合器协议支持兑换的币种列表\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-get-tokens)[\n\n获取流动性列表\n\n获取欧易 DEX 聚合器协议支持兑换的流动性池列表\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-get-liquidity)[\n\n交易授权\n\n提供发起授权交易前所需要的交易信息\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-approve-transaction)[\n\n获取兑换价格\n\n通过欧易 DEX 聚合器获取最优报价\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-get-quote)[\n\n获取 Solana 兑换交易指令\n\n通过欧易 DEX 聚合器获取 Solana 兑换指令\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-solana-swap-instruction)[\n\n兑换\n\n通过欧易 DEX 聚合器路由获取兑换所需的交易数据\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-swap)[\n\n查询交易状态\n\n通过欧易 DEX 聚合器获取兑换交易历史记录\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-swap-history)\n\n[\n\n介绍\n\n](/zh-hans/build/dev-docs/dex-api/dex-swap-api-introduction)[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-get-aggregator-supported-chains)"
    },
    "设置分佣#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n兑换 API\n\n设置分佣\n\n# 设置分佣[#](#设置分佣)\n\nOKX DEX API 支持为代币兑换，配置分佣费用和费用接收地址。\n\n您可以将分佣相关参数包含在兑换报价中，来设置并收取分佣，对多数支持的链，每笔兑换最多收取 3% 的分佣费用，而针对 Solana 链每笔兑换最多收取 10% 的分佣费用。\n\nOKX DEX API 计划从您向用户收取的分佣费中抽取一定比例。更多详细，请访问 [API 费用](./dex-api-fee) 页面。\n\n```json\n// Extended quoteParams with fee support\nconst quoteParams = {\n    chainId: SOLANA_CHAIN_ID,\n    amount: rawAmount,\n    fromTokenAddress,\n    toTokenAddress,\n    slippage: \"0.005\", // 0.5% slippage\n    userWalletAddress: userAddress,\n    // 分佣相关的参数\n    fromTokenReferrerWalletAddress: \"Your_REFERRER_WALLET_ADDRESS\", // Optional: fee receiving address based on fromToken\n    toTokenReferrerWalletAddress: \"Your_REFERRER_WALLET_ADDRESS, // Optional: fee receiving address based on toToken\n    feePercent: \"1.5\",  // Optional: referrer fee percentage (max 9 decimal points)\n\n} as Record<string, string>;\n```\n\n分佣参数配置说明：\n\n*   参数`feePercent`分佣比例，Solana 链最大百分比：10。其他链最大百分比：3\n*   参数`feePercent`最多支持 9 位小数，例如传入 1.3269018736%，但最终计算使用 1.326901873% 作为分佣比例。\n*   对于 Solana，收取分佣的地址必须提前存入一些 SOL 以进行激活。\n*   每笔交易只能从 fromToken 或 toToken 中选择一个作为分佣的来源。\n\n分佣配置详细示例：\n\n```json\n// .. Previous code implementation\n   // Get swap quote\n   const quoteParams = {\n       chainId: SOLANA_CHAIN_ID,\n       amount: rawAmount,\n       fromTokenAddress,\n       toTokenAddress,\n       slippage: \"0.005\", // 0.5% slippage\n       userWalletAddress: userAddress,\n\n       // Additional Fee params\n       fromTokenReferrerWalletAddress: \"fee-recipient-wallet-address\",\n       feePercent: \"1\",\n\n       // The wallet addresses to receive the referrer fee (Each transaction can only choose referrer fee from either the fromToken or the toToken)\n       // toTokenReferrerWalletAddress: \"Fee receiving address,\n       // fromTokenReferrerWalletAddress: \"Fee receiving address\",\n\n   } as Record<string, string>;\n```\n\n```json\nconst timestamp = new Date().toISOString();\n    const requestPath = \"/api/v5/dex/aggregator/swap\";\n    const queryString = \"?\" + new URLSearchParams(quoteParams).toString();\n    const headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\n\n    const response = await fetch(\n        `https://web3.okx.com${requestPath}${queryString}`,\n        { method: \"GET\", headers }\n    );\n\n    const data = await response.json();\n\n    // .. Continue code implementation\n```\n\n分佣配置的命令行：\n\n```json\n# Example: Swap .01 SOL to USDC with 1.5% fee to referrer\nnpx ts-node swap.ts .01 11111111111111111111111111111111 EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v --referrer YOUR_FEE_RECEIVING_ADDRESS --fee 1.5\n```\n\n计算示例的分佣费用说明：\n\n以 1.5% 的分佣比例，向 100 USDC 的交易收取分佣，设置`toTokenReferrerWalletAddress`作为分佣接收地址参数：\n\n*   分佣金额：1.5 USDC（100 USDC 的1.5%）\n*   实际用户兑换成功金额：98.5 USDC\n*   分佣（1.5 USDC）将发送到分佣接收地址\n\n[\n\n查询交易状态\n\n](/zh-hans/build/dev-docs/dex-api/dex-swap-history)[\n\n智能合约\n\n](/zh-hans/build/dev-docs/dex-api/dex-smart-contract)"
    },
    "智能合约#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n兑换 API\n\n智能合约\n\n# 智能合约[#](#智能合约)\n\n欧易 DEX router 合约地址及 ABI\n\n## 合约地址[#](#合约地址)\n\nDEX router 地址和授权合约地址将会由于合约升级而被替换。为避免影响 API 的正常使用，建议使用 `/approve-transaction` API 和`/swap` API 响应参数中的合约地址执行授权或交易操作。\n\n### DEX router 合约地址[#](#dex-router-合约地址)\n\n用于签名交易的欧易 DEX router 地址。\n\n链名称\n\nDEX router 合约地址\n\nEthereum\n\n0xDd5E9B947c99Aa60bab00ca4631Dce63b49983E7\n\nSolana\n\n6m2CDdhRgxpH4WjvdzxAYbGxwdGUz5MziiL5jek2kBma\n\nSUI\n\n0x3b79de9a1f64fed053481f0682b272cdc4ca7ae849699d594cb362b05afe4a2f extended: 0xe810da8bfdec2629a5b78fdd279db943fc1ced2281de3e63f8f7f0588d515ae2 SUI packge id 大小限制，部署 extended 合约，支持 Momentum、Scallop、Haedal、Alphafi 等流动性）\n\nSonic\n\n0x8feB9E84b7E9DC86adc6cD6Eb554C5B4355c8405\n\nTron\n\nTLKfCET238boU5D978DNosBpP8sB9QA6uQ\n\nTon\n\nEQBjfOGw4Iq6FYZplhwZ5rRNb7Htac7WJh8g\\_eQcGTswxVqP\n\nzkSync Era\n\n0x108bfC6aa49718a1f9669FC0Ccd1a21d0D30c8E0\n\nOptimism\n\n0x06f183D52D92c13a5f2B989B8710BA7F00bd6f87\n\nPolygon\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nBNB Chain\n\n0xA2604105e84DAe6eccEa41E61123AB8d9B3AfD75\n\nOKC\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nAvalanche C\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nFantom\n\n0x79f7C6C6dc16Ed3154E85A8ef9c1Ef31CEFaEB19\n\nArbitrum\n\n0x69C236E021F5775B0D0328ded5EaC708E3B869DF\n\nLinea\n\n0xcF76984119C7f6ae56fAfE680d39C08278b7eCF4\n\nConflux eSpace\n\n0x69C236E021F5775B0D0328ded5EaC708E3B869DF\n\nBase\n\n0x69C236E021F5775B0D0328ded5EaC708E3B869DF\n\nMantle\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nScroll\n\n0x06f183D52D92c13a5f2B989B8710BA7F00bd6f87\n\nManta\n\n0x7A7AD9aa93cd0A2D0255326E5Fb145CEc14997FF\n\nMetis\n\n0xC589a4eD6A9fc3354d7eeF88bA87b51AFC272783\n\nBlast\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nZeta\n\n0x7A7AD9aa93cd0A2D0255326E5Fb145CEc14997FF\n\nPolygon zkEvm\n\n0x69C236E021F5775B0D0328ded5EaC708E3B869DF\n\nMerlin\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nX Layer\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nMode\n\n0x8feB9E84b7E9DC86adc6cD6Eb554C5B4355c8405\n\nSEI\n\n0x6733Eb2E75B1625F1Fe5f18aD2cB2BaBDA510d19\n\nUniChain\n\n0x9FD43F5E4c24543b2eBC807321E58e6D350d6a5A\n\nCronos\n\n0x79f7C6C6dc16Ed3154E85A8ef9c1Ef31CEFaEB19\n\n用于签名交易 exact out 的欧易 DEX router 地址。\n\n链名称\n\nDEX router 合约地址\n\nEthereum\n\n0xa875Fb2204cE71679BE054d97f7fAFFeb6536D67\n\nBase\n\n0x77449Ff075C0A385796Da0762BCB46fd5cc884c6\n\nBNB Chain\n\n0x5cb43Bae4f36E2f9f858232B4Dce0dbE27bb85e3\n\nArbitrum\n\n0x9736d9a45115E33411390EbD54e5A5C3A6E25aA6\n\n### 币种授权合约地址[#](#币种授权合约地址)\n\n用于 ERC-20 代币授权的合约地址。Ton，Solana 链不需要授权。\n\n链名称\n\n授权合约地址\n\nEthereum\n\n0x40aA958dd87FC8305b97f2BA922CDdCa374bcD7f\n\nTron\n\nTHRAE2VhGNAcvPKtT96AqyXtSQwhiU1XL8\n\nSonic\n\n0xd321ab5589d3e8fa5df985ccfef625022e2dd910\n\nzkSync Era\n\n0xc67879F4065d3B9fe1C09EE990B891Aa8E3a4c2f\n\nOptimism\n\n0x68D6B739D2020067D1e2F713b999dA97E4d54812\n\nPolygon\n\n0x3B86917369B83a6892f553609F3c2F439C184e31\n\nBNB Chain\n\n0x2c34A2Fb1d0b4f55de51E1d0bDEfaDDce6b7cDD6\n\nOKC\n\n0x70cBb871E8f30Fc8Ce23609E9E0Ea87B6b222F58\n\nAvalanche C\n\n0x40aA958dd87FC8305b97f2BA922CDdCa374bcD7f\n\nFantom\n\n0x70cBb871E8f30Fc8Ce23609E9E0Ea87B6b222F58\n\nArbitrum\n\n0x70cBb871E8f30Fc8Ce23609E9E0Ea87B6b222F58\n\nLinea\n\n0x57df6092665eb6058DE53939612413ff4B09114E\n\nConflux eSpace\n\n0x68D6B739D2020067D1e2F713b999dA97E4d54812\n\nBase\n\n0x57df6092665eb6058DE53939612413ff4B09114E\n\nMantle\n\n0x57df6092665eb6058DE53939612413ff4B09114E\n\nScroll\n\n0x57df6092665eb6058DE53939612413ff4B09114E\n\nManta\n\n0x57df6092665eb6058DE53939612413ff4B09114E\n\nMetis\n\n0x57df6092665eb6058DE53939612413ff4B09114E\n\nBlast\n\n0x5fD2Dc91FF1dE7FF4AEB1CACeF8E9911bAAECa68\n\nZeta\n\n0x03B5ACdA01207824cc7Bc21783Ee5aa2B8d1D2fE\n\nPolygon zkEvm\n\n0x57df6092665eb6058DE53939612413ff4B09114E\n\nMerlin\n\n0x8b773D83bc66Be128c60e07E17C8901f7a64F000\n\nX Layer\n\n0x8b773D83bc66Be128c60e07E17C8901f7a64F000\n\nMode\n\n0xbd0EBE49779E154E5042B34D5BcfBc498e4B3249\n\nSEI\n\n0x801D8ED849039007a7170830623180396492c7ED\n\nUniChain\n\n0x2e28281Cf3D58f475cebE27bec4B8a23dFC7782c\n\nCronos\n\n0x70cbb871e8f30fc8ce23609e9e0ea87b6b222f58\n\n## 二进制合约接口文件 (ABI)[#](#二进制合约接口文件-\\(abi\\))\n\n请参考：[https://github.com/okx/OKX-DEX-Aggregator-ABI](https://github.com/okx/OKX-DEX-Aggregator-ABI)\n\n[\n\n设置分佣\n\n](/zh-hans/build/dev-docs/dex-api/dex-api-addfee)[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-error-code)\n\n目录\n\n[合约地址](#合约地址)[二进制合约接口文件 (ABI)](#二进制合约接口文件-\\(abi\\))"
    },
    "错误码#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n兑换 API\n\n错误码\n\n# 错误码[#](#错误码)\n\n错误码\n\nHTTP 状态\n\n提示信息\n\n0\n\n200\n\n操作成功\n\n50011\n\n429\n\n用户请求频率过快，超过该接口允许的限额。请参考 API 文档并限制请求\n\n50014\n\n400\n\n必填参数 {param0} 不能为空\n\n50026\n\n500\n\n系统错误，请稍后重试\n\n50103\n\n401\n\n请求头“OK\\_ACCESS\\_KEY“不能为空\n\n50104\n\n401\n\n请求头“OK\\_ACCESS\\_PASSPHRASE“不能为空\n\n50105\n\n401\n\n请求头“OK\\_ACCESS\\_PASSPHRASE“错误\n\n50106\n\n401\n\n请求头“OK\\_ACCESS\\_SIGN“不能为空\n\n50107\n\n401\n\n请求头“OK\\_ACCESS\\_TIMESTAMP“不能为空\n\n50111\n\n401\n\n无效的 OK\\_ACCESS\\_KEY\n\n50112\n\n401\n\n无效的 OK\\_ACCESS\\_TIMESTAMP\n\n50113\n\n401\n\n无效的签名\n\n51000\n\n400\n\n{param0} 参数错误\n\n80000\n\n200\n\n重复提交\n\n82000\n\n200\n\n流动性不足\n\n82003\n\n200\n\ntoToken 分佣地址有误\n\n80001\n\n200\n\ncallData 超出最大限制，请在 5 分钟后重试。\n\n80002\n\n200\n\n请求的代币 Object 数量达到上限\n\n80003\n\n200\n\n请求的主网代币 Object 数量达到上限\n\n80004\n\n200\n\n查询 SUI Object 超时\n\n80005\n\n200\n\nsui object 不足\n\n82001\n\n500\n\n分佣服务暂不可用\n\n82102\n\n200\n\n小于最小跨链数,最小数量是 {0}\n\n82103\n\n200\n\n超出最大跨链数,最大数量是 {0}\n\n82104\n\n200\n\n不支持该币种\n\n82105\n\n200\n\n不支持该链\n\n82112\n\n200\n\n当前交易的询价路径价差超过 {num}，可能造成用户的资产损失， 当前默认值是 90%，可通过 priceImpactProtectionPercentage 字段来调节。\n\n82116\n\n200\n\ncallData 超出最大限制，请在 5 分钟后重试。\n\n82130\n\n200\n\n链不需要进行授权交易，可直接兑换\n\n[\n\n智能合约\n\n](/zh-hans/build/dev-docs/dex-api/dex-smart-contract)[\n\nFAQ\n\n](/zh-hans/build/dev-docs/dex-api/dex-aggregation-faq)"
    },
    "FAQ#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n兑换 API\n\nFAQ\n\n# FAQ[#](#faq)\n\n## 每条链的原生代币地址是什么？[#](#每条链的原生代币地址是什么？)\n\n我们对各个链的原生代币进行了定义，可查看下表了解详情\n\n链名称\n\n原生代币地址\n\nEVM\n\n0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\n\nSolana\n\n11111111111111111111111111111111\n\nSui\n\n0x2::sui::SUI\n\nTron\n\nT9yD14Nj9j7xAB4dbGeiX9h8unkKHxuWwb\n\nTon\n\nEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM9c\n\n## 什麼是transfer amount exceeds allowance ?[#](#什麼是transfer-amount-exceeds-allowance-?)\n\n这个错误提示要求您重新设置合约的授权数量，确保它大于您想进行的交易数量。 意味着您尝试执行的转账数量超过了之前授权的数量。\n\n## 什麼是 “min return not reached”?[#](#什麼是-“min-return-not-reached”?)\n\n这是指在执行交易时，预期的最小回报没有达到。这通常发生在交易滑点较大或市场波动较大的情况下。当执行交易时，如果预期的最小回报未能满足，交易就会失败或被取消。\n\n你可以通过提高滑点，来允许交易价格在执行时有更大的波动，从而增加完成交易的可能性。但请注意，过高的滑点可能会导致您的交易结果不如预期。\n\n## 为什麼 token 要授權?[#](#为什麼-token-要授權?)\n\n1.  EVM + Tron：通常是非主网代币，例如在以太坊或 Tron 上发行的代币（ERC-20/TRC-20）需要通过授权（approve）交易。这是为了确保您允许智能合约从您的账户中转移这些代币。\n2.  其他异构链：在一些其他链上，不需要授权，比如 Solana 等链的代币可能不需要类似的授权操作。 总结来说，EVM 和 Tron 中的非主网代币需要授权交易，而其他链的代币可能需要。\n\n[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-error-code)[\n\n介绍\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-introduction)\n\n目录\n\n[每条链的原生代币地址是什么？](#每条链的原生代币地址是什么？)[什麼是transfer amount exceeds allowance ?](#什麼是transfer-amount-exceeds-allowance-?)[什麼是 “min return not reached”?](#什麼是-“min-return-not-reached”?)[为什麼 token 要授權?](#为什麼-token-要授權?)"
    },
    "介绍#_1": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n交易上链 API\n\n介绍\n\n# 介绍[#](#介绍)\n\n这个 API 提供链上模拟和链上交易广播服务，支持自研 RPC 节点和外部付费RPC节点。通过利用 OKX Web3 先进的节点管理基础设施和专业知识，实现智能交易广播，大大降低故障率并加快确认速度。 开发者可以将交易上链 API 与 兑换/跨链 API 无缝集成，为用户创造全面的DEX体验，无需额外的外部资源。\n\n**关键能力**\n\n1.  **高可用性混合节点架构**\n\n*   自研多链节点集群，性能强劲。\n*   智能集成第三方优质节点资源，构建冗余弹性网络。\n*   动态负载平衡，实时节点健康监测和亚秒级故障转移，实现不间断服务。\n\n2.  **智能多播引擎**\n\n*   突破性能力，可同时在多个节点网络上广播交易。\n*   通过先进的分布式传播算法提高链上成功率。\n*   为 ETH、BNB Chain、Solana 等主要链提供优先区块打包加速。\n\n[\n\nFAQ\n\n](/zh-hans/build/dev-docs/dex-api/dex-aggregation-faq)[\n\nAPI 参考\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-reference)"
    },
    "API 参考#_1": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n交易上链 API\n\nAPI 参考\n\n# API 参考[#](#api-参考)\n\n[\n\n获取支持的链\n\n获取支持的链\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-chains)[\n\n获取 Gas Price\n\n获取 Gas Price\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-gas-price)[\n\n获取 Gas Limit\n\n获取 Gas Limit\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-gas-limit)[\n\n获取广播订单列表\n\n获取广播订单列表\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-orders)[\n\n广播交易\n\n将交易广播到链上\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-broadcast-transaction)\n\n[\n\n介绍\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-introduction)[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-chains)"
    },
    "错误码#_1": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[交易 API](/zh-hans/build/dev-docs/dex-api/dex-trade-api-introduction)\n\n交易上链 API\n\n错误码\n\n# 错误码[#](#错误码)\n\n错误码\n\nHTTP 状态\n\n提示信息\n\n50001\n\n200\n\nService temporarily unavailable. Try again later\n\n81001\n\n200\n\nIncorrect parameter\n\n81108\n\n200\n\nWallet type does not match the required type\n\n81104\n\n200\n\nChain not support\n\n81152\n\n200\n\nCoin not exist\n\n81451\n\n200\n\nNode return failed\n\n[\n\n获取广播订单列表\n\n](/zh-hans/build/dev-docs/dex-api/dex-onchain-gateway-api-orders)[\n\n行情 API\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)"
    },
    "API 参考#_2": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n行情价格 API\n\nAPI 参考\n\n# API 参考[#](#api-参考)\n\n[\n\n获取支持的链\n\n获取支持的链信息\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-price-chains)[\n\n获取价格\n\n获取代币的最新价格\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-price)[\n\n获取交易\n\n获取代币的交易数据\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-trades)[\n\n获取 K 线\n\n获取K线数据\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-candlesticks)[\n\n获取历史 K 线\n\n获取历史 K线数据\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-candlesticks-history)\n\n[\n\n行情 API\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-price-chains)"
    },
    "错误码#_2": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n行情价格 API\n\n错误码\n\n# 错误码[#](#错误码)\n\n错误码\n\nHTTP 状态\n\n提示信息\n\n0\n\n200\n\nSucceeded\n\n50011\n\n429\n\nRate limit reached. Please refer to API documentation and throttle requests accordingly\n\n50014\n\n400\n\nParameter {param0} cannot be empty\n\n50026\n\n500\n\nSystem error. Try again later\n\n50103\n\n401\n\nRequest header \"OK-ACCESS-KEY\" cannot be empty\n\n50104\n\n401\n\nRequest header \"OK-ACCESS-PASSPHRASE\" cannot be empty\n\n50105\n\n401\n\nRequest header \"OK-ACCESS-PASSPHRASE\" incorrect\n\n50106\n\n401\n\nRequest header \"OK-ACCESS-SIGN\" cannot be empty\n\n50107\n\n401\n\nRequest header \"OK-ACCESS-TIMESTAMP\" cannot be empty\n\n50111\n\n401\n\nInvalid OK-ACCESS-KEY\n\n50112\n\n401\n\nInvalid OK-ACCESS-TIMESTAMP\n\n50113\n\n401\n\nInvalid signature\n\n51000\n\n400\n\nParameter {param0} error\n\n[\n\n获取历史 K 线\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-candlesticks-history)[\n\nWebsocket\n\n](/zh-hans/build/dev-docs/dex-api/dex-websocket)"
    },
    "Websocket#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n行情价格 API\n\nWebsocket\n\n# Websocket[#](#websocket)\n\nWebsocket 服务仅向白名单客户开放。如果您感兴趣，请联系我们 [dexapi@okx.com](mailto:dexapi@okx.com)。\n\nWebSocket是 HTML5 一种新的协议（Protocol）。它实现了用户端与服务器全双工通信， 使得数据可以快速地双向传播。通过一次简单的握手就可以建立用户端和服务器连接， 服务器根据业务规则可以主动推送信息给用户端。其优点如下：\n\n*   用户端和服务器进行数据传输时，请求头信息比较小，大概2个字节。\n*   用户端和服务器皆可以主动地发送数据给对方。\n*   不需要多次创建 TCP 请求和销毁，节约宽带和服务器的资源。\n\n## 连接[#](#连接)\n\n**连接限制**：3 次/秒 (基于IP)\n\n当订阅私有频道时，使用私有服务的地址\n\n**请求限制**\n\n每个连接 对于 订阅/取消订阅/登录 请求的总次数限制为 480 次/小时 如果出现网络问题，系统会自动断开连接 如果连接成功后 30s 未订阅或订阅后 30s 内服务器未向用户推送数据，系统会自动断开连接\n\n为了保持连接有效且稳定，建议您进行以下操作：\n\n1.  每次接收到消息后，用户设置一个定时器，定时N秒，N 小于 30。\n2.  如果定时器被触发（N 秒内没有收到新消息），发送字符串 'ping'。\n3.  期待一个文字字符串 'pong' 作为回应。如果在 N 秒内未收到，请发出错误或重新连接。\n\n## 通知[#](#通知)\n\nWebSocket有一种消息类型(event=notice)。 用户会在如下场景收到此类信息：\n\n*   Websocket服务升级断线 在推送服务升级前30秒会推送信息，告知用户WebSocket服务即将升级。用户可以重新建立新的连接避免由于断线造成的影响。 响应示例\n\n```json\n{\n    \"event\": \"notice\",\n    \"code\": \"64008\",\n    \"msg\": \"The connection will soon be closed for a service upgrade. Please reconnect.\",\n    \"connId\": \"a4d3ae55\"\n}\n```\n\n[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-market-price-error-code)[\n\n登录\n\n](/zh-hans/build/dev-docs/dex-api/dex-websocket-login)\n\n目录\n\n[连接](#连接)[通知](#通知)"
    },
    "API 参考#_3": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n综合币价 API\n\nAPI 参考\n\n# API 参考[#](#api-参考)\n\n[\n\n获取支持的链\n\n查询当前支持的所有区块链\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-chains)[\n\n获取综合币价\n\n获取综合币价\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price)[\n\n获取历史综合币价\n\n获取历史综合币价\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-historical-index-price)\n\n[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-websocket-error-code)[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-chains)"
    },
    "获取支持的链#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n综合币价 API\n\n[API 参考](/zh-hans/build/dev-docs/dex-api/dex-index-price-reference)\n\n获取支持的链\n\n# 获取支持的链[#](#获取支持的链)\n\n获取综合币价 API 支持的链信息。\n\n### 请求路径[#](#请求路径)\n\nGET `https://web3.okx.com/api/v5/dex/balance/supported/chain`\n\n## 请求参数[#](#请求参数)\n\n无\n\n## 响应参数[#](#响应参数)\n\nParameter\n\nType\n\nDescription\n\nname\n\nString\n\n链名称\n\nlogoUrl\n\nString\n\n链标志 URL\n\nshortName\n\nString\n\n链简称\n\nchainIndex\n\nString\n\n链唯一标识\n\n[\n\nAPI 参考\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-reference)[\n\n获取综合币价\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price)\n\n## 请求示例[#](#请求示例)\n\nshell\n\n```shell\ncurl --location --request GET 'https://web3.okx.com/api/v5/dex/balance/supported/chain'\n--header 'Content-Type: application/json' \\\n--header 'OK-ACCESS-KEY: 37c541a1-****-****-****-10fe7a038418' \\\n--header 'OK-ACCESS-SIGN: leaV********3uw=' \\\n--header 'OK-ACCESS-PASSPHRASE: 1****6' \\\n--header 'OK-ACCESS-TIMESTAMP: 2023-10-18T12:21:41.274Z'\n```\n\n## 响应示例[#](#响应示例)\n\n200\n\n```json\n{\n    \"code\": \"0\",\n    \"data\": [\n        {\n            \"name\": \"Ethereum\",\n            \"logoUrl\": \"http://www.eth.org/eth.png\",\n            \"shortName\": \"ETH\",\n            \"chainIndex\": \"1\"\n        }\n    ],\n    \"msg\": \"\"\n}\n```\n\n[\n\nAPI 参考\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-reference)[\n\n获取综合币价\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price)"
    },
    "获取综合币价#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n综合币价 API\n\n[API 参考](/zh-hans/build/dev-docs/dex-api/dex-index-price-reference)\n\n获取综合币价\n\n# 获取综合币价[#](#获取综合币价)\n\n综合币价指通过多个第三方数据源的价格,计算出来的一个币价。  \n\n批量查询代币的综合价格，每次最多可以批量查询 100 个代币的综合价格。  \n\n按数组格式传递请求参数。\n\n### 请求路径[#](#请求路径)\n\nPOST `https://web3.okx.com/api/v5/dex/index/current-price`\n\n## 请求参数[#](#请求参数)\n\nParameter\n\nType\n\nRequired\n\nDescription\n\nchainIndex\n\nString\n\n是\n\n链唯一标识\n\ntokenContractAddress\n\nString\n\n是\n\n代币地址  \n`1`：传\"\"代表查询对应链的主链币  \n`2`：传具体的代币合约地址，代表查询对应的代币\n\n## 响应参数[#](#响应参数)\n\nParameter\n\nType\n\nDescription\n\nprice\n\nString\n\n代币价格，单位为美元\n\ntime\n\nString\n\n价格的时间，Unix 时间戳格式，用毫秒表示\n\nchainIndex\n\nString\n\n链唯一标识\n\ntokenContractAddress\n\nString\n\n代币地址\n\n[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-chains)[\n\n获取历史综合币价\n\n](/zh-hans/build/dev-docs/dex-api/dex-historical-index-price)\n\n## 请求示例[#](#请求示例)\n\nshell\n\n```shell\ncurl --location --request POST 'https://web3.okx.com/api/v5/dex/index/current-price' \\\n--header 'Content-Type: application/json' \\\n--header 'OK-ACCESS-KEY: 37c541a1-****-****-****-10fe7a038418' \\\n--header 'OK-ACCESS-SIGN: leaV********3uw=' \\\n--header 'OK-ACCESS-PASSPHRASE: 1****6' \\\n--header 'OK-ACCESS-TIMESTAMP: 2023-10-18T12:21:41.274Z' \\\n--data-raw '[\n        {\n            \"chainIndex\": \"1\",\n            \"tokenContractAddress\":\"0xc18360217d8f7ab5e7c516566761ea12ce7f9d72\"\n        }\n    ]'\n```\n\n## 响应示例[#](#响应示例)\n\n200\n\n```json\n{\n    \"code\": \"0\",\n    \"msg\": \"success\",\n    \"data\": [\n        {\n            \"chainIndex\": \"1\",\n            \"tokenContractAddress\": \"0xc18360217d8f7ab5e7c516566761ea12ce7f9d72\"\n            \"time\": \"1716892020000\",\n            \"price\": \"26.458143090226812\",\n        }\n   ]\n}\n```\n\n[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-chains)[\n\n获取历史综合币价\n\n](/zh-hans/build/dev-docs/dex-api/dex-historical-index-price)"
    },
    "获取历史综合币价#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n综合币价 API\n\n[API 参考](/zh-hans/build/dev-docs/dex-api/dex-index-price-reference)\n\n获取历史综合币价\n\n# 获取历史综合币价[#](#获取历史综合币价)\n\n查询某个代币的历史综合价格。\n\n### 请求路径[#](#请求路径)\n\nGET `https://web3.okx.com/api/v5/dex/index/historical-price`\n\n## 请求参数[#](#请求参数)\n\nParameter\n\nType\n\nRequired\n\nDescription\n\nchainIndex\n\nString\n\n是\n\n链唯一标识。(如`1`代表Ethereum。更多可查看[这里](./dex-supported-chain)。)\n\ntokenContractAddress\n\nString\n\n否\n\n代币地址。  \n`1`：传\"\"代表查询对应链的主链币。  \n`2`：传具体的代币合约地址，代表查询对应的代币。\n\nlimit\n\nString\n\n否\n\n每次查询多少条，默认值为 50，最大 200。\n\ncursor\n\nString\n\n否\n\n游标位置，默认为第一个。\n\nbegin\n\nString\n\n否\n\n开始时间，查询晚于该时间的历史币价。Unix时间戳，用毫秒表示。\n\nend ract\n\nString\n\n否\n\n结束时间，查询早于该时间的历史币价。若 begin 和 end 都不传，查询当前时间以前的历史币价。Unix 时间戳，用毫秒表示。\n\nperiod\n\nString\n\n否\n\n时间间隔单位:  \n`1m`: 1分钟  \n`5m`: 5分钟  \n`30m`: 30分钟  \n`1h`: 1小时  \n`1d`: 1天（默认）。\n\n## 响应参数[#](#响应参数)\n\nParameter\n\nType\n\nDescription\n\nprices\n\nArray\n\n历史价格的列表\n\n\\>time\n\nString\n\n分钟时间戳（整分钟）\n\n\\>price\n\nString\n\n币种价格，单位为美元，18 位精度\n\ncursor\n\nString\n\n游标位置\n\n[\n\n获取综合币价\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price)[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-error-code)\n\n## 请求示例[#](#请求示例)\n\nshell\n\n```shell\ncurl --location --request GET 'https://web3.okx.com/api/v5/dex/index/historical-price?chainIndex=1&limit=5&begin=1700040600000&period=5m' \\\n\n--header 'OK-ACCESS-KEY: 37c541a1-****-****-****-10fe7a038418' \\\n--header 'OK-ACCESS-SIGN: leaV********3uw=' \\\n--header 'OK-ACCESS-PASSPHRASE: 1****6' \\\n--header 'OK-ACCESS-TIMESTAMP: 2023-10-18T12:21:41.274Z' \n```\n\n## 响应示例[#](#响应示例)\n\n200\n\n```json\n{\n    \"code\": \"0\",\n    \"msg\": \"success\",\n    \"data\": [\n        {\n        \"cursor\":\"31\",\n        \"prices\":[\n            {\n                \"time\": \"1700040600000\",\n                \"price\": \"1994.430000000000000000\"\n            },\n            {\n                \"time\": \"1700040300000\",\n                \"price\": \"1994.190000000000000000\"\n            },\n            {\n                \"time\": \"1700040000000\",\n                \"price\": \"1992.090000000000000000\"\n            },\n            {\n                \"time\": \"1700039700000\",\n                \"price\": \"1992.190000000000000000\"\n            },\n            {\n                \"time\": \"1700039400000\",\n                \"price\": \"1990.190000000000000000\"\n            }\n        ]\n      }\n    ]\n}\n```\n\n[\n\n获取综合币价\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price)[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-error-code)"
    },
    "错误码#_3": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n综合币价 API\n\n错误码\n\n# 错误码[#](#错误码)\n\n错误码\n\nHTTP 状态\n\n提示信息\n\n81001\n\n200\n\nIncorrect parameter\n\n[\n\n获取历史综合币价\n\n](/zh-hans/build/dev-docs/dex-api/dex-historical-index-price)[\n\nAPI 参考\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-reference)"
    },
    "API 参考#_4": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n余额 API\n\nAPI 参考\n\n# API 参考[#](#api-参考)\n\n[\n\n获取支持的链\n\n获取支持的链\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-chains)[\n\n获取总估值\n\n获取总估值\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-total-value)[\n\n获取资产明细\n\n获取资产明细\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-total-token-balances)[\n\n获取特定代币余额\n\n获取特定代币余额\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-specific-token-balance)\n\n[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-index-price-error-code)[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-chains)"
    },
    "错误码#_4": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n余额 API\n\n错误码\n\n# 错误码[#](#错误码)\n\n错误码\n\nHTTP 状态\n\n提示信息\n\n50014\n\n400\n\nparam {param0} is invalid\n\n50001\n\n200\n\nService temporarily unavailable. Try again later\n\n81001\n\n200\n\nIncorrect parameter: : {param0}\n\n50011\n\n429\n\nToo Many Requests\n\n81104\n\n200\n\nChain not support\n\n81001\n\n200\n\nRequired request body is missing\n\n[\n\n获取特定代币余额\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-specific-token-balance)[\n\nAPI 参考\n\n](/zh-hans/build/dev-docs/dex-api/dex-tx-history-reference)"
    },
    "API 参考#_5": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n交易历史 API\n\nAPI 参考\n\n# API 参考[#](#api-参考)\n\n[\n\n获取支持的链\n\n查询当前支持的所有区块链网络\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-tx-history-chains)[\n\n获取交易历史\n\n查询地址维度下的交易历史\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-tx-history-transactions-by-address)[\n\n获取特定交易\n\n根据 txHash 查询某个交易的详情\n\n\n\n](/zh-hans/build/dev-docs/dex-api/dex-tx-history-specific-transaction-detail-by-txhash)\n\n[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-balance-error-code)[\n\n获取支持的链\n\n](/zh-hans/build/dev-docs/dex-api/dex-tx-history-chains)"
    },
    "错误码#_5": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[行情 API](/zh-hans/build/dev-docs/dex-api/dex-market-api-introduction)\n\n交易历史 API\n\n错误码\n\n# 错误码[#](#错误码)\n\n错误码\n\nHTTP 状态\n\n提示信息\n\n81001\n\n200\n\nIncorrect parameter\n\n[\n\n获取特定交易\n\n](/zh-hans/build/dev-docs/dex-api/dex-tx-history-specific-transaction-detail-by-txhash)[\n\n介绍\n\n](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)"
    },
    "介绍#_2": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[资源](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)\n\nDEX SDK\n\n介绍\n\n# 介绍[#](#介绍)\n\nOKX DEX SDK 是一个 typescript 工具包，可供开发人员将 OKX DEX API 功能集成到他们的 App 里。  \n\nGitHub 存储库： [https://github.com/okx/okx-dex-sdk](https://github.com/okx/okx-dex-sdk)  \n\n如何操作： [https://github.com/okx/okx-dex-sdk?tab=readme-ov-file#usage](https://github.com/okx/okx-dex-sdk?tab=readme-ov-file#usage)\n\n## 安装 SDK[#](#安装-sdk)\n\n```bash\nnpm install @okx-dex/okx-dex-sdk\n# or\nyarn add @okx-dex/okx-dex-sdk\n# or\npnpm add @okx-dex/okx-dex-sdk\n```\n\n## 环境设置[#](#环境设置)\n\n请使用你的 API 凭证和钱包信息来创建一个 .env 文件。\n\n```bash\n# OKX API Credentials\nOKX_API_KEY=your_api_key\nOKX_SECRET_KEY=your_secret_key\nOKX_API_PASSPHRASE=your_passphrase\nOKX_PROJECT_ID=your_project_id\n\n# Solana Configuration\nSOLANA_RPC_URL=your_solana_rpc_url\nSOLANA_WALLET_ADDRESS=your_solana_wallet_address\nSOLANA_PRIVATE_KEY=your_solana_private_key\n\n# EVM Configuration\nEVM_RPC_URL=your_evm_rpc_url\nEVM_PRIVATE_KEY=your_evm_private_key\n```\n\n## 客户端初始化[#](#客户端初始化)\n\n为 DEX 客户端创建文件 (例如 DexClient.ts):\n\n```typescript\n// example.ts or test.ts\nimport { OKXDexClient } from '@okx-dex/okx-dex-sdk';\nimport { Connection } from '@solana/web3.js';\nimport { createWallet } from '@okx-dex/okx-dex-sdk/core/wallet';\nimport 'dotenv/config';\nimport { createEVMWallet } from '@okx-dex/okx-dex-sdk/core/evm-wallet';\nimport { ethers } from 'ethers';\n\n// Validate environment variables\nconst requiredEnvVars = [\n    'OKX_API_KEY',\n    'OKX_SECRET_KEY', \n    'OKX_API_PASSPHRASE',\n    'OKX_PROJECT_ID',\n    'SOLANA_RPC_URL',\n    'SOLANA_PRIVATE_KEY',\n    'EVM_RPC_URL',\n    'EVM_PRIVATE_KEY'\n];\n\nfor (const envVar of requiredEnvVars) {\n    if (!process.env[envVar]) {\n        throw new Error(`Missing required environment variable: ${envVar}`);\n    }\n}\n\n// Create Solana connection and wallet\nconst connection = new Connection(process.env.SOLANA_RPC_URL!);\nconst wallet = createWallet(process.env.SOLANA_PRIVATE_KEY!, connection);\n\n// Create EVM provider and wallet\nconst provider = new ethers.JsonRpcProvider(process.env.EVM_RPC_URL!);\nconst evmWallet = createEVMWallet(process.env.EVM_PRIVATE_KEY!, provider);\n\n// Initialize the client with both Solana and EVM support\nexport const client = new OKXDexClient({\n    apiKey: process.env.OKX_API_KEY!,\n    secretKey: process.env.OKX_SECRET_KEY!,\n    apiPassphrase: process.env.OKX_API_PASSPHRASE!,\n    projectId: process.env.OKX_PROJECT_ID!,\n    solana: {\n        wallet: wallet\n    },\n    evm: {\n        wallet: evmWallet\n    }\n});\n```\n\n## Using the Client[#](#using-the-client)\n\nOnce initialized, you can use the client to make DEX API calls:\n\n```typescript\nasync function main() {\n    try {\n        // Get tokens for Solana (chainId: 501)\n        const tokens = await client.dex.getTokens(\"501\");\n        console.log('Supported tokens:', JSON.stringify(tokens, null, 2));\n        \n        // Get tokens for Ethereum (chainId: 1)\n        const ethTokens = await client.dex.getTokens(\"1\");\n        console.log('Ethereum tokens:', JSON.stringify(ethTokens, null, 2));\n        \n    } catch (error) {\n        console.error('Error:', error);\n    }\n}\nmain();\n```\n\n[\n\n错误码\n\n](/zh-hans/build/dev-docs/dex-api/dex-tx-history-error-code)[\n\nEVM 示例\n\n](/zh-hans/build/dev-docs/dex-api/dex-sdk-evm)\n\n目录\n\n[安装 SDK](#安装-sdk)[环境设置](#环境设置)[客户端初始化](#客户端初始化)[Using the Client](#using-the-client)"
    },
    "EVM 示例#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[资源](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)\n\nDEX SDK\n\nEVM 示例\n\n# EVM 示例[#](#evm-示例)\n\n## 执行授权指令[#](#执行授权指令)\n\n```javascript\n// approval.ts\nimport { client } from './DexClient';\n// Helper function to convert human-readable amounts to base units\nexport function toBaseUnits(amount: string, decimals: number): string {\n    // Remove any decimal point and count the decimal places\n    const [integerPart, decimalPart = ''] = amount.split('.');\n    const currentDecimals = decimalPart.length;\n\n    // Combine integer and decimal parts, removing the decimal point\n    let result = integerPart + decimalPart;\n\n    // Add zeros if we need more decimal places\n    if (currentDecimals < decimals) {\n        result = result + '0'.repeat(decimals - currentDecimals);\n    }\n    // Remove digits if we have too many decimal places\n    else if (currentDecimals > decimals) {\n        result = result.slice(0, result.length - (currentDecimals - decimals));\n    }\n\n    // Remove leading zeros\n    result = result.replace(/^0+/, '') || '0';\n\n    return result;\n}\n/**\n * Example: Approve a token for swapping\n */\nasync function executeApproval(tokenAddress: string, amount: string) {\n    try {\n        // Get token information using quote\n        console.log(\"Getting token information...\");\n        const tokenInfo = await client.dex.getQuote({\n            chainId: '8453',  // Base Chain\n            fromTokenAddress: tokenAddress,\n            toTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE', // Native token\n            amount: '1000000', // Use a reasonable amount for quote\n            slippage: '0.005' // 0.5% slippage\n        });\n        const tokenDecimals = parseInt(tokenInfo.data[0].fromToken.decimal);\n        const rawAmount = toBaseUnits(amount, tokenDecimals);\n        console.log(`\\nApproval Details:`);\n        console.log(`--------------------`);\n        console.log(`Token: ${tokenInfo.data[0].fromToken.tokenSymbol}`);\n        console.log(`Amount: ${amount} ${tokenInfo.data[0].fromToken.tokenSymbol}`);\n        console.log(`Amount in base units: ${rawAmount}`);\n        // Execute the approval\n        console.log(\"\\nExecuting approval...\");\n        const result = await client.dex.executeApproval({\n            chainId: '8453',  // Base Chain\n            tokenContractAddress: tokenAddress,\n            approveAmount: rawAmount\n        });\n        if ('alreadyApproved' in result) {\n            console.log(\"\\nToken already approved for the requested amount!\");\n            return { success: true, alreadyApproved: true };\n        } else {\n            console.log(\"\\nApproval completed successfully!\");\n            console.log(\"Transaction Hash:\", result.transactionHash);\n            console.log(\"Explorer URL:\", result.explorerUrl);\n            return result;\n        }\n    } catch (error) {\n        if (error instanceof Error) {\n            console.error('Error executing approval:', error.message);\n        }\n        throw error;\n    }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n    // Example usage: ts-node approval.ts 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913 1000\n    const args = process.argv.slice(2);\n    if (args.length !== 2) {\n        console.log(\"Usage: ts-node approval.ts <tokenAddress> <amountToApprove>\");\n        console.log(\"\\nExamples:\");\n        console.log(\"  # Approve 1000 USDC\");\n        console.log(`  ts-node approval.ts 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913 1000`);\n        process.exit(1);\n    }\n    const [tokenAddress, amount] = args;\n    executeApproval(tokenAddress, amount)\n        .then(() => process.exit(0))\n        .catch((error) => {\n            console.error('Error:', error);\n            process.exit(1);\n        });\n}\nexport { executeApproval };\n\n```\n\n## 创建兑换指令[#](#创建兑换指令)\n\n```javascript\n// swap.ts\nimport { client } from './DexClient';\n/**\n * Example: Execute a swap from ETH to USDC on Base chain\n */\nasync function executeSwap() {\n  try {\n    if (!process.env.EVM_PRIVATE_KEY) {\n      throw new Error('Missing EVM_PRIVATE_KEY in .env file');\n    }\n    // You can change this to any EVM chain\n    // For example, for Base, use chainId: '8453'\n    // For example, for baseSepolia, use chainId: '84532'\n    // You can also use SUI, use chainId: '784'\n    // When using another Chain, you need to change the fromTokenAddress and toTokenAddress to the correct addresses for that chain\n\n    const swapResult = await client.dex.executeSwap({\n      chainId: '8453', // Base chain ID\n      fromTokenAddress: '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE', // Native ETH\n      toTokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC on Base\n      amount: String(10 * 10 ** 14), // .0001 ETH\n      slippage: '0.005', // 0.5% slippage\n      userWalletAddress: process.env.EVM_WALLET_ADDRESS!\n    });\n    console.log('Swap executed successfully:');\n    console.log(JSON.stringify(swapResult, null, 2));\n\n    return swapResult;\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error('Error executing swap:', error.message);\n      // API errors include details in the message\n      if (error.message.includes('API Error:')) {\n        const match = error.message.match(/API Error: (.*)/);\n        if (match) console.error('API Error Details:', match[1]);\n      }\n    }\n    throw error;\n  }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n  executeSwap()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Error:', error);\n      process.exit(1);\n    });\n}\nexport { executeSwap };\n\n```\n\n## 获取报价[#](#获取报价)\n\n```javascript\nconst quote = await client.dex.getQuote({\n    chainId: '8453',  // Base Chain\n    fromTokenAddress: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', // USDC\n    toTokenAddress: '0x4200000000000000000000000000000000000006', // WETH\n    amount: '1000000',  // 1 USDC (in smallest units)\n    slippage: '0.005'     // 0.5% slippage\n});\n\n```\n\n[\n\n介绍\n\n](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)[\n\nSolana 示例\n\n](/zh-hans/build/dev-docs/dex-api/dex-sdk-solana)\n\n目录\n\n[执行授权指令](#执行授权指令)[创建兑换指令](#创建兑换指令)[获取报价](#获取报价)"
    },
    "Solana 示例#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[资源](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)\n\nDEX SDK\n\nSolana 示例\n\n# Solana 示例[#](#solana-示例)\n\n## 创建兑换指令[#](#创建兑换指令)\n\n```javascript\n// swap.ts\nimport { client } from './DexClient';\n/**\n * Example: Execute a swap from SOL to USDC\n */\nasync function executeSwap() {\n  try {\n    if (!process.env.SOLANA_PRIVATE_KEY) {\n      throw new Error('Missing SOLANA_PRIVATE_KEY in .env file');\n    }\n    // Get quote to fetch token information\n    console.log(\"Getting token information...\");\n    const quote = await client.dex.getQuote({\n        chainId: '501',\n        fromTokenAddress: '11111111111111111111111111111111', // SOL\n        toTokenAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n        amount: '1000000', // Small amount for quote\n        slippage: '0.005'// 0.5% slippage\n    });\n    const tokenInfo = {\n        fromToken: {\n            symbol: quote.data[0].fromToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].fromToken.decimal),\n            price: quote.data[0].fromToken.tokenUnitPrice\n        },\n        toToken: {\n            symbol: quote.data[0].toToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].toToken.decimal),\n            price: quote.data[0].toToken.tokenUnitPrice\n        }\n    };\n    // Convert amount to base units (for display purposes)\n    const humanReadableAmount = 0.1; // 0.1 SOL\n    const rawAmount = (humanReadableAmount * Math.pow(10, tokenInfo.fromToken.decimals)).toString();\n    console.log(\"\\nSwap Details:\");\n    console.log(\"--------------------\");\n    console.log(`From: ${tokenInfo.fromToken.symbol}`);\n    console.log(`To: ${tokenInfo.toToken.symbol}`);\n    console.log(`Amount: ${humanReadableAmount} ${tokenInfo.fromToken.symbol}`);\n    console.log(`Amount in base units: ${rawAmount}`);\n    console.log(`Approximate USD value: $${(humanReadableAmount * parseFloat(tokenInfo.fromToken.price)).toFixed(2)}`);\n    // Execute the swap\n    console.log(\"\\nExecuting swap...\");\n    const swapResult = await client.dex.executeSwap({\n      chainId: '501', // Solana chain ID\n      fromTokenAddress: '11111111111111111111111111111111', // SOL\n      toTokenAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n      amount: rawAmount,\n      slippage: '0.005', // 0.5% slippage\n      userWalletAddress: process.env.SOLANA_WALLET_ADDRESS!\n    });\n    console.log('Swap executed successfully:');\n    console.log(JSON.stringify(swapResult, null, 2));\n\n    return swapResult;\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error('Error executing swap:', error.message);\n      // API errors include details in the message\n      if (error.message.includes('API Error:')) {\n        const match = error.message.match(/API Error: (.*)/);\n        if (match) console.error('API Error Details:', match[1]);\n      }\n    }\n    throw error;\n  }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n  executeSwap()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Error:', error);\n      process.exit(1);\n    });\n}\nexport { executeSwap };\n```\n\n## 获取报价[#](#获取报价)\n\n```javascript\nconst quote = await client.dex.getQuote({\n    chainId: '501',  // Solana\n    fromTokenAddress: '11111111111111111111111111111111', // SOL\n    toTokenAddress: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC\n    amount: '100000000',  // 0.1 SOL (in lamports)\n    slippage: '0.005'     // 0.5% slippage\n});\n```\n\n## 执行兑换指令[#](#执行兑换指令)\n\n导入以下代码库\n\n```javascript\n// Required Solana dependencies for DEX interaction\nimport {\n    Connection,          // Handles RPC connections to Solana network\n    Keypair,             // Manages wallet keypairs for signing\n    PublicKey,           // Handles Solana public key conversion and validation\n    TransactionInstruction,    // Core transaction instruction type\n    TransactionMessage,        // Builds transaction messages (v0 format)\n    VersionedTransaction,      // Supports newer transaction format with lookup tables\n    RpcResponseAndContext,     // RPC response wrapper type\n    SimulatedTransactionResponse,  // Simulation result type\n    AddressLookupTableAccount,     // For transaction size optimization\n    PublicKeyInitData              // Public key input type\n} from \"@solana/web3.js\";\nimport base58 from \"bs58\";    // Required for private key decoding\n```\n\n连线和钱包初始化\n\n```javascript\n// Note: Consider using a reliable RPC endpoint with high rate limits for production\nconst connection = new Connection(\n   process.env.SOLANA_RPC_URL || \"https://api.mainnet-beta.solana.com\"\n);\n// Initialize wallet for signing\n// This wallet will be the fee payer and transaction signer\nconst wallet = Keypair.fromSecretKey(\n   Uint8Array.from(base58.decode(userPrivateKey))\n);\n```\n\n## 设置兑换参数[#](#设置兑换参数)\n\n```javascript\n// Configure swap parameters\nconst baseUrl = \"https://web3.okx.com/api/v5/dex/aggregator/swap-instruction\";\nconst params = {\n    chainId: \"501\",              // Solana mainnet chain ID\n    feePercent: \"1\",             // Platform fee percentage\n    amount: \"1000000\",           // Amount in smallest denomination (lamports for SOL)\n    fromTokenAddress: \"11111111111111111111111111111111\",  // SOL mint address\n    toTokenAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",  // USDC mint address\n    slippage: \"0.1\",             // Slippage tolerance 10%\n    userWalletAddress: userAddress,   // Wallet performing the swap\n    priceTolerance: \"0\",         // Maximum allowed price impact\n    autoSlippage: \"false\",       // Use fixed slippage instead of auto\n    pathNum: \"3\"                 // Maximum routes to consider\n};\n```\n\n## 兑换指令[#](#兑换指令)\n\n```javascript\n// Helper function to convert DEX API instructions to Solana format\nfunction createTransactionInstruction(instruction) {\n    return new TransactionInstruction({\n        programId: new PublicKey(instruction.programId),  // DEX program ID\n        keys: instruction.accounts.map((key) => ({\n            pubkey: new PublicKey(key.pubkey),    // Account address\n            isSigner: key.isSigner,     // True if account must sign tx\n            isWritable: key.isWritable  // True if instruction modifies account\n        })),\n        data: Buffer.from(instruction.data, 'base64')  // Instruction parameters\n    });\n}\n// Fetch optimal swap route and instructions from DEX\nconst timestamp = new Date().toISOString();\nconst requestPath = \"/api/v5/dex/aggregator/swap-instruction\";\nconst queryString = \"?\" + new URLSearchParams(params).toString();\nconst headers = getHeaders(timestamp, \"GET\", requestPath, queryString);\nconst response = await fetch(\n    `https://web3.okx.com${requestPath}${queryString}`,\n    { method: 'GET', headers }\n);\nconst { data } = await response.json();\nconst { instructionLists, addressLookupTableAccount } = data;\n// Process DEX instructions into Solana-compatible format\nconst instructions = [];\n// Remove duplicate lookup table addresses returned by DEX\nconst uniqueLookupTables = Array.from(new Set(addressLookupTableAccount));\nconsole.log(\"Lookup tables to load:\", uniqueLookupTables);\n// Convert each DEX instruction to Solana format\nif (instructionLists?.length) {\n    instructions.push(...instructionLists.map(createTransactionInstruction));\n}\n```\n\n## 地址查找表[#](#地址查找表)\n\n```javascript\n// Process lookup tables for transaction optimization\n// Lookup tables are crucial for complex swaps that interact with many accounts\n// They significantly reduce transaction size and cost\nconst addressLookupTableAccounts = [];\nif (uniqueLookupTables?.length > 0) {\n    console.log(\"Loading address lookup tables...\");\n    // Fetch all lookup tables in parallel for better performance\n    const lookupTableAccounts = await Promise.all(\n        uniqueLookupTables.map(async (address) => {\n            const pubkey = new PublicKey(address);\n            // Get lookup table account data from Solana\n            const account = await connection\n                .getAddressLookupTable(pubkey)\n                .then((res) => res.value);\n            if (!account) {\n                throw new Error(`Could not fetch lookup table account ${address}`);\n            }\n            return account;\n        })\n    );\n    addressLookupTableAccounts.push(...lookupTableAccounts);\n}\n```\n\n## 创建并签署交易[#](#创建并签署交易)\n\n```javascript\n// Get recent blockhash for transaction timing and uniqueness\nconst latestBlockhash = await connection.getLatestBlockhash('finalized');\n// Create versioned transaction message (V0 format required for lookup table support)\nconst messageV0 = new TransactionMessage({\n    payerKey: wallet.publicKey,     // Fee payer address\n    recentBlockhash: latestBlockhash.blockhash,  // Transaction timing\n    instructions                     // Swap instructions from DEX\n}).compileToV0Message(addressLookupTableAccounts);  // Include lookup tables\n// Create new versioned transaction with optimizations\nconst transaction = new VersionedTransaction(messageV0);\n// Simulate transaction to check for errors\n// This helps catch issues before paying fees\nconst result = await connection.simulateTransaction(transaction);\n// Sign transaction with fee payer wallet\ntransaction.sign([wallet]);\n```\n\n## 执行交易[#](#执行交易)\n\n```javascript\n// Send transaction to Solana\n// skipPreflight=false ensures additional validation\n// maxRetries helps handle network issues\nconst txId = await connection.sendRawTransaction(transaction.serialize(), {\n    skipPreflight: false,  // Run preflight validation\n    maxRetries: 5         // Retry on failure\n});\n// Log transaction results\nconsole.log(\"Transaction ID:\", txId);\nconsole.log(\"Explorer URL:\", `https://solscan.io/tx/${txId}`);\n// Wait for confirmation\nawait connection.confirmTransaction({\n    signature: txId,\n    blockhash: latestBlockhash.blockhash,\n    lastValidBlockHeight: latestBlockhash.lastValidBlockHeight\n});\nconsole.log(\"Transaction confirmed!\");\n```\n\n[\n\nEVM 示例\n\n](/zh-hans/build/dev-docs/dex-api/dex-sdk-evm)[\n\nSui 示例\n\n](/zh-hans/build/dev-docs/dex-api/dex-sdk-sui)\n\n目录\n\n[创建兑换指令](#创建兑换指令)[获取报价](#获取报价)[执行兑换指令](#执行兑换指令)"
    },
    "Sui 示例#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[资源](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)\n\nDEX SDK\n\nSui 示例\n\n# Sui 示例[#](#sui-示例)\n\n## 创建币种助手 (可忽略)[#](#创建币种助手-\\(可忽略\\))\n\n```javascript\n// Common tokens on Sui mainnet\nexport const TOKENS = {\n    SUI: \"0x2::sui::SUI\",\n    USDC: \"0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC\"\n} as const;\n\n```\n\n## 创建兑换指令[#](#创建兑换指令)\n\n```javascript\n// swap.ts\nimport { client } from './DexClient';\nimport { TOKENS } from './Tokens'; // Optional, if you created the token helper\n/**\nExample: Execute a swap from SUI to USDC\n*/\nasync function executeSwap() {\n  try {\n    if (!process.env.SUI_PRIVATE_KEY) {\n      throw new Error('Missing SUI_PRIVATE_KEY in .env file');\n    }\n    // First, get token information using a quote\n    console.log(\"Getting token information...\");\n    const fromTokenAddress = TOKENS.SUI; // Or use directly: \"0x2::sui::SUI\"\n    const toTokenAddress = TOKENS.USDC; // Or use directly: \"0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC\"\n\n    const quote = await client.dex.getQuote({\n        chainId: '784', // Sui chain ID\n        fromTokenAddress,\n        toTokenAddress,\n        amount: '1000000', // Small amount for quote\n        slippage: '0.005' // 0.5% slippage\n    });\n    const tokenInfo = {\n        fromToken: {\n            symbol: quote.data[0].fromToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].fromToken.decimal),\n            price: quote.data[0].fromToken.tokenUnitPrice\n        },\n        toToken: {\n            symbol: quote.data[0].toToken.tokenSymbol,\n            decimals: parseInt(quote.data[0].toToken.decimal),\n            price: quote.data[0].toToken.tokenUnitPrice\n        }\n    };\n    // Convert amount to base units\n    const humanReadableAmount = 1.5; // 1.5 SUI\n    const rawAmount = (humanReadableAmount * Math.pow(10, tokenInfo.fromToken.decimals)).toString();\n    console.log(\"\\nSwap Details:\");\n    console.log(\"--------------------\");\n    console.log(\nFrom: ${tokenInfo.fromToken.symbol}\n);\n    console.log(\nTo: ${tokenInfo.toToken.symbol}\n);\n    console.log(\nAmount: ${humanReadableAmount} ${tokenInfo.fromToken.symbol}\n);\n    console.log(\nAmount in base units: ${rawAmount}\n);\n    console.log(\nApproximate USD value: $${(humanReadableAmount * parseFloat(tokenInfo.fromToken.price)).toFixed(2)}\n);\n    // Execute the swap\n    console.log(\"\\nExecuting swap...\");\n    const swapResult = await client.dex.executeSwap({\n      chainId: '784', // Sui chain ID\n      fromTokenAddress,\n      toTokenAddress,\n      amount: rawAmount,\n      slippage: '0.005', // 0.5% slippage\n      userWalletAddress: process.env.SUI_WALLET_ADDRESS!\n    });\n    console.log('Swap executed successfully:');\n    console.log(\"\\nTransaction ID:\", swapResult.transactionId);\n    console.log(\"Explorer URL:\", swapResult.explorerUrl);\n\n    if (swapResult.details) {\n        console.log(\"\\nDetails:\");\n        console.log(\nInput: ${swapResult.details.fromToken.amount} ${swapResult.details.fromToken.symbol}\n);\n        console.log(\nOutput: ${swapResult.details.toToken.amount} ${swapResult.details.toToken.symbol}\n);\n        if (swapResult.details.priceImpact) {\n            console.log(\nPrice Impact: ${swapResult.details.priceImpact}%\n);\n        }\n    }\n\n    return swapResult;\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error('Error executing swap:', error.message);\n      // API errors include details in the message\n      if (error.message.includes('API Error:')) {\n        const match = error.message.match(/API Error: (.*)/);\n        if (match) console.error('API Error Details:', match[1]);\n      }\n    }\n    throw error;\n  }\n}\n// Run if this file is executed directly\nif (require.main === module) {\n  executeSwap()\n    .then(() => process.exit(0))\n    .catch((error) => {\n      console.error('Error:', error);\n      process.exit(1);\n    });\n}\nexport { executeSwap };\n\n```\n\n## 获取报价[#](#获取报价)\n\n```javascript\nconst quote = await client.dex.getQuote({\n    chainId: '784',  // Sui\n    fromTokenAddress: '0x2::sui::SUI', // SUI\n    toTokenAddress: '0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC', // USDC\n    amount: '100000000',  // In base units\n    slippage: '0.005'     // 0.5% slippage\n});\n```\n\n[\n\nSolana 示例\n\n](/zh-hans/build/dev-docs/dex-api/dex-sdk-solana)[\n\n使用 Widget\n\n](/zh-hans/build/dev-docs/dex-api/dex-widget)\n\n目录\n\n[创建币种助手 (可忽略)](#创建币种助手-\\(可忽略\\))[创建兑换指令](#创建兑换指令)[获取报价](#获取报价)"
    },
    "Javascript 签名 SDK#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[资源](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)\n\n钱包签名 SDK\n\nJavascript 签名 SDK\n\n# Javascript 签名 SDK[#](#javascript-签名-sdk)\n\n## 概述[#](#概述)\n\nJs-wallet-sdk 是一个基于 TypeScript/JavaScript 语言的钱包解决方案，包括了各条公链不同的密码学算法和常用功能，可以使用它离线进行私钥、地址的创建，组装交易，以及进行签名等等。本文档将详细介绍如何使用此 SDK。目前，它已经支持各种主流的区块链，每种币种类别都有独立的模块实现，我们将在未来持续增加对更多区块链的支持。\n\n### 支持平台[#](#支持平台)\n\n作为一个 Javascript SDK，它支持各种浏览器和 JavaScript 环境，可以轻松地集成到 Web 应用、移动应用或桌面应用中。\n\n## 安装和构建[#](#安装和构建)\n\n### NPM 构建[#](#npm-构建)\n\n要使用签名 SDK，首先需要安装它，你可以使用 npm 安装来获取到最新版本。\n\n我们的签名 SDK 支持两种类型的包：公共包和单币种模块。\n\n公共包，针对所有币种：\n\n```bash\nnpm install @okxweb3/crypto-lib\nnpm install @okxweb3/coin-base\n```\n\n集成单个币种，以 ETH 和 BTC 为例：\n\n集成 ETH:\n\n```bash\nnpm install @okxweb3/coin-ethereum\n```\n\n集成 BTC:\n\n```bash\nnpm install @okxweb3/coin-bitcoin\n```\n\n### 本地构建[#](#本地构建)\n\n在本地构建 SDK：\n\n1.  下载项目源码\n\n```bash\ngit clone https://github.com/okx/js-wallet-sdk.git\n```\n\n2.  运行构建脚本\n\n```bash\nsh build.sh\n```\n\n## 主要功能[#](#主要功能)\n\n以下是签名 SDK 中每个模块的具体功能介绍。\n\n*   crypto-lib: 这个模块提供了常用的安全加密算法和签名算法等。\n*   coin-base: 这个模块提供了币种通用接口。\n*   coin-\\*: 这个模块实现了各个币种交易构建和签名的方法。每种币种都有一个对应的模块，例如 coin-ethereum、coin-bitcoin 等。这些模块提供了针对特定币种的交易构建和签名方法。\n\n## Packages[#](#packages)\n\n包名\n\n模块\n\n描述\n\n[@okxweb3/coin-base](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-base/README.md)\n\ncoin-base\n\n我们为这些链或币种提供通用功能，使得访问这些链变得非常简单。\n\n[@okxweb3/crypto-lib](https://github.com/okx/js-wallet-sdk/blob/main/packages/crypto-lib/README.md)\n\ncrypto-lib\n\n我们提供关于 bip32、bip39、ecdsa、ed25519 等的通用函数。\n\n[@okxweb3/coin-aptos](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-aptos/README.md)\n\ncoin-aptos\n\nAptos SDK 用于与 Aptos 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-bitcoin](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-bitcoin/README.md)\n\ncoin-bitcoin\n\nBitcoin SDK 用于与 Bitcoin 主网或测试网交互，包含可用于 web3 钱包的各种函数。SDK 不仅支持 Bitcoin，还支持以下链：BTC,BSV,DOGE,LTC,TBTC\n\n[@okxweb3/coin-cosmos](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-cosmos/README.md)\n\ncoin-cosmos\n\nCosmos SDK 用于与 Cosmos 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-eos](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-eos/README.md)\n\ncoin-eos\n\nEOS SDK 用于与 EOS 区块链交互，包含可用于 web3 钱包的各种函数。SDK 不仅支持 EOS，还支持 WAX。\n\n[@okxweb3/coin-ethereum](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-ethereum/README.md)\n\ncoin-ethereum\n\nEthereum SDK 用于与Ethereum 区块链或 EVM 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-flow](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-flow/README.md)\n\ncoin-flow\n\nFlow SDK 用于与 Flow 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-near](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-near/README.md)\n\ncoin-near\n\nNear SDK 用于与 Near 协议交互，包含与 Near 生态系统交互时需要的主要函数。\n\n[@okxweb3/coin-polkadot](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-polkadot/README.md)\n\ncoin-polkadot\n\nPolkadot SDK 用于与 Polkadot 区块链交互，包含与 Polkadot 生态系统交互时需要的主要函数。\n\n[@okxweb3/coin-solana](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-solana/README.md)\n\ncoin-solana\n\nSolana SDK 用于与 Solana 链交互，包含与 Solana 生态系统交互时需要的主要函数。\n\n[@okxweb3/coin-stacks](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-stacks/README.md)\n\ncoin-stacks\n\nStacks SDK 用于与 Stacks 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-starknet](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-starknet/README.md)\n\ncoin-starknet\n\nStarknet SDK 用于与 Starknet 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-sui](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-sui/README.md)\n\ncoin-sui\n\nSUI SDK 用于与 SUI 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-tron](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-tron/README.md)\n\ncoin-tron\n\nTRX SDK 用于与TRON区块链交互，包含可用于 web3 钱包的各种函数。\n\n[@okxweb3/coin-zkspace](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-zkspace/README.md)\n\ncoin-zkspace\n\nZKSpace SDK 用于与 ZK 合约交互，包含可用于 web3 钱包的各种函数。SDK 不仅支持 ZKSpace，还支持 zkSync。\n\n### coin-base[#](#coin-base)\n\nbase 包是所有币种的公共基础模块，提供币种通用的接口方法定义，例如：随机生成私钥、私钥派生、获取派生路径等。目前，单币种的实现包基本实现了通用的接口方法，不同币种支持的功能函数略有不同，具体可以参考各币种实现包的功能函数说明。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-base\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签名交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nvalidPrivateKey\n\n验证私钥\n\nsignMessage\n\n签名消息\n\nverifyMessage\n\n验证签名消息\n\necRecover\n\n恢复签名到公钥\n\ngetAddressByPublicKey\n\n通过公钥获取地址\n\ngetHardWareRawTransaction\n\n获取硬件的原始交易\n\ngetHardWareSignedTransaction\n\n获取硬件的签名交易\n\ngetHardWareMessageHash\n\n获取硬件的消息哈希\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\ngetRawTransaction\n\n生成原始交易数据\n\nvalidSignedTransaction\n\n检查签名交易\n\nestimateFee\n\n估计燃气费\n\n关于 coin-base 包支持的功能函数和使用案例，更详细的内容可以查看 github 文档：[coin-base功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-base/README.md#supporting-functions)。\n\n### crypto-lib[#](#crypto-lib)\n\n这是一个包含了 bip32, bip39, ecdsa, ed25519 等常用的安全加密和签名算法的实现，例如：\n\n*   bip32 常用函数：这些函数主要用于处理和操作比特币改进型支付协议（BIP32）相关的任务。\n*   bip39 生成助记词、公私钥、签名消息函数：这些函数主要用于处理和操作比特币改进型支付协议（BIP39）相关的任务，如生成助记词，公私钥，以及签名消息。\n*   常用的哈希和编解码函数：这些函数主要用于处理常见的哈希和编解码任务，如 SHA256 哈希，Base64 编解码等。\n*   ed5519 常用签名函数：这些函数主要用于处理和操作 ed5519 签名算法相关的任务。\n*   ecds 常用签名函数：这些函数主要用于处理和操作椭圆曲线数字签名算法（ECDSA）相关的任务。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/crypto-lib\n```\n\n关于 crypto-lib 包支持的功能函数和使用案例，更详细的内容可以查看 github 文档：[crypto-lib功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/crypto-lib/README.md#provides)。\n\n### coin-aptos[#](#coin-aptos)\n\nAptos SDK 主要用集成 Aptos 区块链，包含有私钥生成、私钥派生、生成地址、交易转帐等功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-aptos\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成一个随机的私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新的地址\n\nvalidAddress\n\n验证地址的有效性\n\nsignTransaction\n\n对交易进行签名\n\ngetDerivedPath\n\n获取 bip44 路径\n\nsignMessage\n\n对消息进行签名\n\nverifyMessage\n\n验证签名消息的有效性\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\nvalidSignedTransaction\n\n检查已签名的交易的有效性\n\nAptos 交易支持类型有：\n\n\"transfer\"、\"tokenTransfer\"、\"tokenMint\"、\"tokenBurn\"、\"tokenRegister\"、\"dapp\"、\"simulate\"、\"offerNft\"、\"claimNft\"、\"offerNft\\_simulate\"、\"claimNft\\_simulate\"\n\n关于 coin-aptos 包支持的功能函数和使用案例，可以查看 github 文档以获取更详细的内容：[coin-aptos功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-aptos/README.md#usage)。\n\n### coin-bitcoin[#](#coin-bitcoin)\n\ncoin-bitcoin 是一个用于集成 Bitcoin 区块链的 SDK，它支持 Bitcoin 的主网和测试网，并提供了一系列的功能函数，使开发者能够更方便地与 Bitcoin 区块链进行交互。除了 BTC，它还支持 BSV、DOGE、LTC 和 TBTC 等币种。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-bitcoin\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成一个随机的私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新的地址\n\nvalidAddress\n\n验证地址的有效性\n\nsignTransaction\n\n对交易进行签名\n\ngetDerivedPath\n\n获取 bip44 路径\n\nsignMessage\n\n对消息进行签名\n\nverifyMessage\n\n验证签名消息的有效性\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\nvalidSignedTransaction\n\n检查已签名的交易的有效性\n\ngetAddressByPublicKey\n\n通过公钥获取地址\n\n关于 coin-bitcoin 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-bitcoin功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-bitcoin/README.md#using-bitcoin-sdk)。\n\n### coin-cosmos[#](#coin-cosmos)\n\nCosmos SDK 是一个用于集成 Cosmos 架构的区块链的工具包，它提供了一系列的功能函数，包括生成私钥、派生私钥、生成地址和交易转账等。它支持的币种包括：\n\n*   Atom\n*   Axelar\n*   Cronos\n*   Evmos\n*   Iris\n*   Juno\n*   Kava\n*   Kujira\n*   Osmos\n*   Secret\n*   Sei\n*   Stargaze\n*   Terra\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-cosmos\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nsignMessage\n\n签署消息\n\nverifyMessage\n\n验证签署的消息\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\nvalidSignedTransaction\n\n检查已签署的交易\n\ngetAddressByPublicKey\n\n通过公钥获取地址\n\n关于 coin-cosmos 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-cosmos功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-cosmos/README.md#using-cosmos-sdk)。\n\n### coin-eos[#](#coin-eos)\n\nEOS SDK 是一个用于集成 EOS 区块链的工具包，它提供了一系列的功能函数，包括生成私钥、派生私钥、生成地址和交易序列化等。除了 EOS 外，它还支持 Wax 币种。\n\n这些功能函数使开发者能够更方便地与 EOS 区块链进行交互，包括创建和管理钱包，发送和接收交易，以及查询区块链信息等。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-eos\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\n关于 coin-eos 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-eos功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-eos/README.md#using-eos-sdk)。\n\n### coin-ethereum[#](#coin-ethereum)\n\nEthereum SDK 是一个用于集成 Ethereum 区块链和其他 支持EVM (以太坊虚拟机) 的区块链的工具包。它提供了一系列的功能函数，包括生成私钥、派生私钥、生成地址和交易转账等。\n\n这些功能函数使开发者能够更方便地与 Ethereum 区块链进行交互，包括创建和管理钱包，发送和接收交易，以及查询区块链信息等。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-ethereum\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nvalidPrivateKey\n\n验证私钥\n\nsignMessage\n\n签署消息\n\nverifyMessage\n\n验证签署的消息\n\necRecover\n\n恢复签名到公钥\n\ngetAddressByPublicKey\n\n通过公钥获取地址\n\ngetHardWareRawTransaction\n\n获取硬件的原始交易\n\n关于 coin-ethereum 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-ethereum功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-ethereum/README.md#using-ethereum-sdk)。\n\n### coin-flow[#](#coin-flow)\n\nFlow 区块链是一个新一代的、面向未来的区块链平台，它专为高性能应用和游戏而设计。\n\nFlow SDK 是一个用于集成 Flow 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-flow\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\nvalidateAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\nFlow 交易支持类型有：Account 和 Transfer\n\n关于 coin-flow 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-flow 功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-flow/README.md#using-flow-sdk)。\n\n### coin-near[#](#coin-near)\n\nNear 协议是一个可扩展的区块链平台，它通过使用新颖的共识机制和分片技术，实现了高吞吐量和低延迟的交易处理。Near SDK 使开发者能够更方便地开发和部署在 Near 区块链上的应用。\n\nNear SDK 是一个用于集成 Near 协议的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-near\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetAddress\n\n通过种子获取地址\n\nvalidateAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ntransfer\n\n转账\n\nfullAccessKey\n\n获取完全访问密钥\n\npublicKeyFromSeed\n\n从种子获取公钥\n\n关于 coin-near 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-near功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-near/README.md#using-near-sdk)。\n\n### coin-polkadot[#](#coin-polkadot)\n\nPolkadot 是一个多链异构的区块链平台，它允许各种区块链网络以共享的安全模型并行运行，同时还能实现链与链之间的信息和价值的无缝转移。\n\nPolkadot SDK 是一个用于集成 Polkadot 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-polkadot\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetAddress\n\n通过种子获取地址\n\nvalidateAddress\n\n验证地址\n\nSignTx\n\n签署交易\n\n关于 coin-polkadot 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-polkadot 功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-polkadot/README.md#using-polkadot-sdk)。\n\n### coin-solana[#](#coin-solana)\n\nSolana 是一个高性能的区块链平台，它通过创新的共识算法和区块产生机制，实现了高吞吐量和低延迟的交易处理。\n\nSolana SDK 是一个用于集成 Solana 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-solana\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nsignMessage\n\n签署消息\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\nvalidSignedTransaction\n\n检查已签署的交易\n\ngetHardWareRawTransaction\n\n获取硬件的原始交易\n\ngetHardWareSignedTransaction\n\n获取硬件的已签署交易\n\ngetHardWareMessageHash\n\n获取硬件的消息哈希\n\n关于 coin-solana 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-solana功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-solana/README.md#using-solana-sdk)。\n\n### coin-stacks[#](#coin-stacks)\n\nStacks 是一个开源的区块链平台，它允许开发者在 Stacks 区块链上构建智能合约和去中心化应用。\n\nStacks SDK 主要用集成 Stacks 区块链，包含多种用于集成 web3 钱包的功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-stacks\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nsignMessage\n\n签署消息\n\nverifyMessage\n\n验证签名消息\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\ngetRawTransaction\n\n获取原始交易\n\n关于 coin-stacks 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-stacks 功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-stacks/README.md#using-stacks-sdk)。\n\n### coin-starknet[#](#coin-starknet)\n\nStarkNet 是一个去中心化的、可扩展的区块链网络，它使用了零知识证明技术来提高交易处理的效率和安全性。\n\nStarkNet SDK 是一个用于集成 StarkNet 区块链的工具包，它提供了一系列的功能函数，使开发者能够更方便地与 StarkNet 区块链进行交互。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-starknet\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nsignMessage\n\n签署消息\n\nverifyMessage\n\n验证签名消息\n\n关于 coin-starknet 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-starknet 功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-starknet/README.md#using-starknet-sdk)。\n\n### coin-sui[#](#coin-sui)\n\nSUI SDK 是一个用于集成 SUI 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-sui\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nsignMessage\n\n签署消息\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\n提示\n\n注意：与 secp256k1 不同的是，ed25519 的私钥派生只支持 hard 模式的派生，详情参见：[https://github.com/satoshilabs/slips/blob/master/slip-0010.md](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)\n\n关于 coin-sui 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-sui 功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-sui/README.md#usage)。\n\n### coin-tron[#](#coin-tron)\n\nTRON SDK 是一个用于集成 TRON 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-tron\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nvalidPrivateKey\n\n验证私钥\n\nsignMessage\n\n签署消息\n\nverifyMessage\n\n验证签名消息\n\necRecover\n\n恢复签名到公钥\n\ngetAddressByPublicKey\n\n通过公钥获取地址\n\ngetHardWareRawTransaction\n\n获取硬件的原始交易\n\ngetHardWareSignedTransaction\n\n获取硬件的签名交易\n\ngetHardWareMessageHash\n\n获取硬件的消息哈希\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\ngetRawTransaction\n\n生成原始交易数据\n\nvalidSignedTransaction\n\n检查签名交易\n\n关于 coin-tron 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-tron 功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-tron/README.md#using-trx-sdk)。\n\n### coin-zkspace[#](#coin-zkspace)\n\nZKSpace SDK 主要用集成 ZK 合约，包含多种用于集成 web3 钱包的功能函数，除了 ZKSpace 外，还支持 zkSync。\n\n通过 npm 获取最新版本的包：\n\n```bash\nnpm install @okxweb3/coin-zkspace\n```\n\n支持函数：\n\n函数名称\n\n功能\n\n备注\n\ngetRandomPrivateKey\n\n生成随机私钥\n\ngetDerivedPrivateKey\n\n从 DerivePriKeyParams 生成私钥\n\ngetNewAddress\n\n通过私钥获取新地址\n\nvalidAddress\n\n验证地址\n\nsignTransaction\n\n签署交易\n\ngetDerivedPath\n\n获取 bip44 路径\n\nvalidPrivateKey\n\n验证私钥\n\nsignMessage\n\n签署消息\n\nverifyMessage\n\n验证签名消息\n\necRecover\n\n恢复签名到公钥\n\ngetAddressByPublicKey\n\n通过公钥获取地址\n\ngetHardWareRawTransaction\n\n获取硬件的原始交易\n\ngetHardWareSignedTransaction\n\n获取硬件的签名交易\n\ngetHardWareMessageHash\n\n获取硬件的消息哈希\n\ncalcTxHash\n\n通过原始交易获取交易哈希\n\ngetRawTransaction\n\n生成原始交易数据\n\n交易签名支持 data 类型有：transfer 和 changePubkey\n\n关于 coin-zkspace 包支持的功能函数和使用案例，更加详细内容可以查看 github 文档：[coin-zkspace 功能函数](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-zkspace/README.md#using-zkspace-sdk)。\n\n## 测试用例[#](#测试用例)\n\n在 github 上，每个模块对应的 package 下有一个 `tests` 目录，放有各个币种模块的测试用例，可以通过测试用例了解到更多关于 SDK 中函数的用法。\n\n币种\n\n测试用例\n\n备注\n\nBTC\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-bitcoin/tests/btc.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-bitcoin/tests/btc.test.ts)\n\nETH\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-ethereum/tests/eth.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-ethereum/tests/eth.test.ts)\n\nCosmos\n\n[https://github.com/okx/js-wallet-sdk/tree/main/packages/coin-cosmos/tests](https://github.com/okx/js-wallet-sdk/tree/main/packages/coin-cosmos/tests)\n\nAptos\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-aptos/tests/aptos.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-aptos/tests/aptos.test.ts)\n\nEOS\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-eos/tests/eos.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-eos/tests/eos.test.ts)\n\nSolana\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-solana/tests/sol.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-solana/tests/sol.test.ts)\n\nStacks\n\n[https://github.com/okx/js-wallet-sdk/tree/main/packages/coin-stacks/tests](https://github.com/okx/js-wallet-sdk/tree/main/packages/coin-stacks/tests)\n\nStarknet\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-starknet/tests/crypto.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-starknet/tests/crypto.test.ts)\n\nSUI\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-sui/tests/crypto.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-sui/tests/crypto.test.ts)\n\nTRON\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-tron/tests/trx.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-tron/tests/trx.test.ts)\n\nZKSpace\n\n[https://github.com/okx/js-wallet-sdk/tree/main/packages/coin-zkspace/tests](https://github.com/okx/js-wallet-sdk/tree/main/packages/coin-zkspace/tests)\n\nFlow\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-flow/tests/flow.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-flow/tests/flow.test.ts)\n\nNear\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-near/tests/near.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-near/tests/near.test.ts)\n\nPolkadot\n\n[https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-polkadot/tests/dot.test.ts](https://github.com/okx/js-wallet-sdk/blob/main/packages/coin-polkadot/tests/dot.test.ts)\n\n## 支持币种[#](#支持币种)\n\n币族\n\n币种\n\n派生路径\n\nBTC\n\nBTC\n\n常规地址：  \nm/44'/0'/0/0'/0  \n隔离见证：  \nm/49'/0'/0/0'/0  \nm/84'/0'/0/0'/0  \nm/86'/0'/0/0'/0\n\nBTC\n\nBCH\n\nm/44'/145'/0'/0/0\n\nBTC\n\nBSV\n\nm/44'/236'/0'/0/0\n\nBTC\n\nLTC\n\nm/44'/2'/0'/0/0\n\nBTC\n\nDoge\n\nm/44'/3'/0'/0/0\n\nBTC\n\nTBTC\n\nm/44'/0'/0/0'/0\n\nBTC\n\nOmni usdt\n\nm/44'/0'/0/0'/0\n\nETH\n\nETH\n\nm/44'/60'/0'/0/0\n\nETH\n\nArbitrum One\n\nm/44'/60'/0'/0/0\n\nETH\n\nArbitrum Nova\n\nm/44'/60'/0'/0/0\n\nETH\n\nAvalanche C\n\nm/44'/60'/0'/0/0\n\nETH\n\nBoba\n\nm/44'/60'/0'/0/0\n\nETH\n\nBNB Chain\n\nm/44'/60'/0'/0/0\n\nETH\n\nBase\n\nm/44'/60'/0'/0/0\n\nETH\n\nCore\n\nm/44'/60'/0'/0/0\n\nETH\n\nCronos(EVM)\n\nm/44'/60'/0'/0/0\n\nETH\n\nCelo\n\nm/44'/60'/0'/0/0\n\nETH\n\nConflux(EVM)\n\nm/44'/60'/0'/0/0\n\nETH\n\nEndurance\n\nm/44'/60'/0'/0/0\n\nETH\n\nEthereumPoW\n\nm/44'/60'/0'/0/0\n\nETH\n\nEthereumFair\n\nm/44'/60'/0'/0/0\n\nETH\n\nFilecoin EVM\n\nm/44'/60'/0'/0/0\n\nETH\n\nFantom\n\nm/44'/60'/0'/0/0\n\nETH\n\nFlare\n\nm/44'/60'/0'/0/0\n\nETH\n\nGnosis\n\nm/44'/60'/0'/0/0\n\nETH\n\nGoerli\n\nm/44'/60'/0'/0/0\n\nETH\n\nHAQQ Network\n\nm/44'/60'/0'/0/0\n\nETH\n\nKlaytn\n\nm/44'/60'/0'/0/0\n\nETH\n\nKCC\n\nm/44'/60'/0'/0/0\n\nETH\n\nKava EVM\n\nm/44'/60'/0'/0/0\n\nETH\n\nLinea\n\nm/44'/60'/0'/0/0\n\nETH\n\nMetis\n\nm/44'/60'/0'/0/0\n\nETH\n\nMoonebeam\n\nm/44'/60'/0'/0/0\n\nETH\n\nMoonriver\n\nm/44'/60'/0'/0/0\n\nETH\n\nMantle\n\nm/44'/60'/0'/0/0\n\nETH\n\nOmega Network\n\nm/44'/60'/0'/0/0\n\nETH\n\nOKTC\n\nm/44'/60'/0'/0/0\n\nETH\n\nOptimism\n\nm/44'/60'/0'/0/0\n\nETH\n\nopBNB\n\nm/44'/60'/0'/0/0\n\nETH\n\nPolygon\n\nm/44'/60'/0'/0/0\n\nETH\n\nPolygon zkEVM\n\nm/44'/60'/0'/0/0\n\nETH\n\nPulseChain\n\nm/44'/60'/0'/0/0\n\nETH\n\nSepolia\n\nm/44'/60'/0'/0/0\n\nETH\n\nzkSync Era\n\nm/44'/60'/0'/0/0\n\nETH\n\nZetaChian\n\nm/44'/60'/0'/0/0\n\nCosmos\n\nAtom\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nAxelar\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nCronos\n\nm/44'/394'/0'/0/0\n\nCosmos\n\nOsmos\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nEvmos\n\nm/44'/60'/0'/0/0\n\nCosmos\n\nIris\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nJuno\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nKava\n\nm/44'/459'/0'/0/0\n\nCosmos\n\nKujira\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nSecret\n\nm/44'/529'/0'/0/0\n\nCosmos\n\nSei\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nStargaze\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nTerra\n\nm/44'/330'/0'/0/0\n\nAptos\n\nAptos\n\nm/44'/637'/0'/0/0\n\nEOS\n\nEOS\n\nm/44'/194'/0'/0/0\n\nSolana\n\nSolana\n\nm/44'/501'/0'/0/0\n\nStacks\n\nStacks\n\nm/44'/5757'/0'/0/0\n\nETH layer 2\n\nStarknet\n\nm/44'/9004'/0'/0/0\n\nSUI\n\nSUI\n\nm/44'/784'/0'/0/0\n\nTRX\n\nTRON\n\nm/44'/195'/0'/0/0\n\nETH layer 2\n\nZKSpace\n\nm/44'/60'/0'/0/0\n\nETH layer 2\n\nzkSync\n\nm/44'/60'/0'/0/0\n\n[\n\n使用 Widget\n\n](/zh-hans/build/dev-docs/dex-api/dex-widget)[\n\nGo 签名 SDK\n\n](/zh-hans/build/dev-docs/dex-api/private-key-wallet-go-sdk)\n\n目录\n\n[概述](#概述)[安装和构建](#安装和构建)[主要功能](#主要功能)[Packages](#packages)[测试用例](#测试用例)[支持币种](#支持币种)"
    },
    "Go 签名 SDK#": {
      "doc": "[DEX API](/zh-hans/build/dev-docs/dex-api/dex-what-is-dex-api)\n\n[资源](/zh-hans/build/dev-docs/dex-api/dex-sdk-introduction)\n\n钱包签名 SDK\n\nGo 签名 SDK\n\n# Go 签名 SDK[#](#go-签名-sdk)\n\n## 概述[#](#概述)\n\nGo-wallet-sdk 是一个基于 Go 语言的钱包解决方案，包括了各条公链不同的密码学算法和常用功能，可以使用它离线进行私钥、地址的创建，组装交易，以及进行签名等等。本文档将详细介绍如何使用此 SDK。目前，它已经支持各种主流的区块链，每种币种类别都有独立的模块实现，我们将在未来持续增加对更多区块链的支持。\n\n### 支持平台[#](#支持平台)\n\n作为一个 Go SDK，可以轻松地集成到 Web 应用、移动应用或桌面应用中。\n\n## 安装和构建[#](#安装和构建)\n\n### Go GET[#](#go-get)\n\n要使用签名 SDK，首先需要安装它，你可以使用 `go get` 安装来获取到最新版本。\n\n我们的签名 SDK 支持两种类型的包：公共包和单币种模块。\n\n公共包，针对所有币种：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/crypto\n```\n\n集成单个币种，以 ETH 和 BTC 为例：\n\n集成 ETH:\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/ethereum\n```\n\n集成 BTC:\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/bitcoin\n```\n\n## 主要功能[#](#主要功能)\n\n以下是签名 SDK 中每个模块的具体功能介绍。\n\n*   crypto: 这个模块提供了常用的安全加密算法和签名算法等。\n*   coins: 这个模块实现了各个币种交易构建和签名的方法。每种币种都有一个对应的模块，例如 ethereum、bitcoin 等。这些模块提供了针对特定币种的交易构建和签名方法。\n\n## Packages[#](#packages)\n\n包名\n\n模块\n\n描述\n\n[github.com/okx/go-wallet-sdk/crypto](https://github.com/okx/go-wallet-sdk/tree/main/crypto)\n\ncrypto\n\n我们提供关于 bip32、bip39、ecdsa、ed25519 等的通用函数。\n\n[github.com/okx/go-wallet-sdk/coins/aptos](https://github.com/okx/go-wallet-sdk/tree/main/coins/aptos)\n\naptos\n\nAptos SDK 用于与 Aptos 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/bitcoin](https://github.com/okx/go-wallet-sdk/tree/main/coins/bitcoin)\n\nbitcoin\n\nBitcoin SDK 用于与 Bitcoin 主网或测试网交互，包含可用于 web3 钱包的各种函数。SDK 不仅支持 Bitcoin，还支持以下链：BTC, BSV, DOGE, LTC, TBTC。\n\n[github.com/okx/go-wallet-sdk/coins/cosmos](https://github.com/okx/go-wallet-sdk/tree/main/coins/cosmos)\n\ncosmos\n\nCosmos SDK 用于与 Cosmos 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/eos](https://github.com/okx/go-wallet-sdk/tree/main/coins/eos)\n\neos\n\nEOS SDK 用于与 EOS 区块链交互，包含可用于 web3 钱包的各种函数。SDK 不仅支持 EOS，还支持 WAX。\n\n[github.com/okx/go-wallet-sdk/coins/ethereum](https://github.com/okx/go-wallet-sdk/tree/main/coins/ethereum)\n\nethereum\n\nEthereum SDK 用于与 Ethereum 区块链或 EVM 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/flow](https://github.com/okx/go-wallet-sdk/tree/main/coins/flow)\n\nflow\n\nFlow SDK 用于与 Flow 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/near](https://github.com/okx/go-wallet-sdk/tree/main/coins/near)\n\nnear\n\nNear SDK 用于与 Near 协议交互，包含与 Near 生态系统交互时需要的主要函数。\n\n[github.com/okx/go-wallet-sdk/coins/polkadot](https://github.com/okx/go-wallet-sdk/tree/main/coins/polkadot)\n\npolkadot\n\nPolkadot SDK 用于与 Polkadot 区块链交互，包含与 Polkadot 生态系统交互时需要的主要函数。\n\n[github.com/okx/go-wallet-sdk/coins/solana](https://github.com/okx/go-wallet-sdk/tree/main/coins/solana)\n\nsolana\n\nSolana SDK 用于与 Solana 链交互，包含与 Solana 生态系统交互时需要的主要函数。\n\n[github.com/okx/go-wallet-sdk/coins/stacks](https://github.com/okx/go-wallet-sdk/tree/main/coins/stacks)\n\nstacks\n\nStacks SDK 用于与 Stacks 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/starknet](https://github.com/okx/go-wallet-sdk/tree/main/coins/starknet)\n\nstarknet\n\nStarknet SDK 用于与 Starknet 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/sui](https://github.com/okx/go-wallet-sdk/tree/main/coins/sui)\n\nsui\n\nSUI SDK 用于与 SUI 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/tron](https://github.com/okx/go-wallet-sdk/tree/main/coins/tron)\n\ntron\n\nTRX SDK 用于与 TRON 区块链交互，包含可用于 web3 钱包的各种函数。\n\n[github.com/okx/go-wallet-sdk/coins/zkspace](https://github.com/okx/go-wallet-sdk/tree/main/coins/zkspace)\n\nzkspace\n\nZKSpace SDK 用于与 ZK 合约交互，包含可用于 web3 钱包的各种函数。SDK 不仅支持 ZKSpace，还支持 zkSync。\n\n### crypto[#](#crypto)\n\n这是一个包含了 BIP32, BIP39, ECDSA, ED25519 等常用的安全加密和签名算法的实现，例如：\n\n*   BIP32 常用函数：这些函数主要用于处理和操作比特币改进型支付协议 (BIP32) 相关的任务。\n*   BIP39 生成助记词、公私钥、签名消息函数：这些函数主要用于处理和操作比特币改进型支付协议 (BIP39) 相关的任务，如生成助记词，公私钥，以及签名消息。\n*   常用的哈希和编解码函数：这些函数主要用于处理常见的哈希和编解码任务，如 SHA256 哈希，Base64 编解码等。\n*   ED25519 常用签名函数：这些函数主要用于处理和操作 ED25519 签名算法相关的任务。\n*   ECDSA 常用签名函数：这些函数主要用于处理和操作椭圆曲线数字签名算法 (ECDSA) 相关的任务。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/crypto\n```\n\n### aptos-sdk[#](#aptos-sdk)\n\nAptos SDK 主要用集成 Aptos 区块链，包含有私钥生成、私钥派生、生成地址、交易转帐等功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/aptos\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新的地址\n\nValidateAddress\n\n验证地址的有效性\n\nSignRawTransaction\n\n对交易进行签名\n\nAptos 交易支持类型有：\n\n\"transfer\"、\"tokenTransfer\"、\"tokenMint\"、\"tokenBurn\"、\"tokenRegister\"、\"dapp\"、\"simulate\"、\"offerNft\"、\"claimNft\"、\"offerNft\\_simulate\"、\"claimNft\\_simulate\"\n\n关于 aptos-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/blob/main/coins/aptos/) 文档。\n\n### bitcoin-sdk[#](#bitcoin-sdk)\n\nbitcoin-sdk 是一个用于集成 Bitcoin 区块链的 SDK，它支持 Bitcoin 的主网和测试网，并提供了一系列的功能函数，使开发者能够更方便地与 Bitcoin 区块链进行交互。除了 BTC，它还支持 BSV、DOGE、LTC 和 TBTC 等币种。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/bitcoin\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新的地址\n\nSignTx\n\n对交易进行签名\n\nGenerateUnsignedPSBTHex\n\nPSBT生成交易\n\n关于 bitcoin-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/bitcoin) 文档。\n\n### cosmos-sdk[#](#cosmos-sdk)\n\nCosmos SDK 是一个用于集成 Cosmos 架构的区块链的工具包，它提供了一系列的功能函数，包括生成私钥、派生私钥、生成地址和交易转账等。它支持的币种包括：\n\n*   Atom\n*   Axelar\n*   Cronos\n*   Evmos\n*   Iris\n*   Juno\n*   Kava\n*   Kujira\n*   Osmos\n*   Secret\n*   Sei\n*   Stargaze\n*   Terra\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/cosmos\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nTransfer\n\n签署交易\n\nSignMessage\n\n签署消息\n\n关于 cosmos-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/cosmos) 文档。\n\n### eos-sdk[#](#eos-sdk)\n\nEOS SDK 是一个用于集成 EOS 区块链的工具包，它提供了一系列的功能函数，包括生成私钥、派生私钥、生成地址和交易序列化等。除了 EOS 外，它还支持 WAX 币种。 这些功能函数使开发者能够更方便地与 EOS 区块链进行交互，包括创建和管理钱包，发送和接收交易，以及查询区块链信息等。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/eos\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nSignTransaction\n\n签署交易\n\n关于 eos-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/eos) 文档。\n\n### ethereum-sdk[#](#ethereum-sdk)\n\nEthereum SDK 是一个用于集成 Ethereum 区块链和其他支持 EVM（以太坊虚拟机）的区块链的工具包。它提供了一系列的功能函数，包括生成私钥、派生私钥、生成地址和交易转账等。 这些功能函数使开发者能够更方便地与 Ethereum 区块链进行交互，包括创建和管理钱包，发送和接收交易，以及查询区块链信息等。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/ethereum\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nSignTransaction\n\n签署交易\n\nSignMessage\n\n签署消息\n\n关于 ethereum-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/ethereum) 文档。\n\n### flow-sdk[#](#flow-sdk)\n\nFlow 区块链是一个新一代的、面向未来的区块链平台，它专为高性能应用和游戏而设计。 Flow SDK 是一个用于集成 Flow 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/flow\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nCreateNewAccountTx\n\n创建地址\n\nSignTx\n\n签署交易\n\nFlow 交易支持类型有：Account 和 Transfer\n\n关于 flow-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/flow) 文档。\n\n### near-sdk[#](#near-sdk)\n\nNear 协议是一个可扩展的区块链平台，它通过使用新颖的共识机制和分片技术，实现了高吞吐量和低延迟的交易处理。Near SDK 使开发者能够更方便地开发和部署在 Near 区块链上的应用。 Near SDK 是一个用于集成 Near 协议的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/near\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAccount\n\n通过种子获取地址\n\nSignTransaction\n\n签署交易\n\n关于 near-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/near) 文档。\n\n### polkadot-sdk[#](#polkadot-sdk)\n\nPolkadot 是一个多链异构的区块链平台，它允许各种区块链网络以共享的安全模型并行运行，同时还能实现链与链之间的信息和价值的无缝转移。 Polkadot SDK 是一个用于集成 Polkadot 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/polkadot\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过种子获取地址\n\nSignTx\n\n签署交易\n\n关于 polkadot-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/polkadot) 文档。\n\n### solana-sdk[#](#solana-sdk)\n\nSolana 是一个高性能的区块链平台，它通过创新的共识算法和区块产生机制，实现了高吞吐量和低延迟的交易处理。 Solana SDK 是一个用于集成 Solana 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/solana\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nSignTransaction\n\n签署交易\n\n关于 solana-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/solana) 文档。\n\n### stacks-sdk[#](#stacks-sdk)\n\nStacks 是一个开源的区块链平台，它允许开发者在 Bitcoin 区块链上构建智能合约和去中心化应用。 Stacks SDK 主要用集成 Stacks 区块链，包含多种用于集成 web3 钱包的功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/stacks\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nTransfer\n\n签署交易\n\n关于 stacks-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/stacks) 文档。\n\n### starknet-sdk[#](#starknet-sdk)\n\nStarkNet 是一个去中心化的、可扩展的区块链网络，它使用了零知识证明技术来提高交易处理的效率和安全性。 StarkNet SDK 是一个用于集成 StarkNet 区块链的工具包，它提供了一系列的功能函数，使开发者能够更方便地与 StarkNet 区块链进行交互。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/starknet\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nCreateSignedContractTx\n\n签署交易\n\n关于 starknet-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/starknet) 文档。\n\n### sui-sdk[#](#sui-sdk)\n\nSUI SDK 是一个用于集成 SUI 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/sui\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nSignTransaction\n\n签署交易\n\nSignMessage\n\n签署消息\n\n注意：与 secp256k1 不同的是，ed25519 的私钥派生只支持 hard 模式的派生，详情参见：[https://github.com/satoshilabs/slips/blob/master/slip-0010.md](https://github.com/satoshilabs/slips/blob/master/slip-0010.md)\n\n关于 sui-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/sui) 文档。\n\n### tron-sdk[#](#tron-sdk)\n\nTRON SDK 是一个用于集成 SUI 区块链的工具包，包含多种用于集成 web3 钱包的功能函数。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/tron\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nSignTransaction\n\n签署交易\n\n关于 tron-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/tron) 文档。\n\n### zkspace-sdk[#](#zkspace-sdk)\n\nZKSpace SDK 主要用集成 ZK 合约，包含多种用于集成 web3 钱包的功能函数，除了 ZKSpace 外，还支持 ZKSync。\n\n通过 `go get` 获取最新版本的包：\n\n```bash\ngo get -u github.com/okx/go-wallet-sdk/coins/zkspace\n```\n\n支持函数：\n\n函数名称\n\n功能\n\nNewAddress\n\n通过私钥获取新地址\n\nCreateSignTransferTx\n\n签署交易\n\n交易签名支持 data 类型有：transfer 和 changePubkey\n\n关于 zkspace-sdk 包支持的功能函数和使用案例，更加详细内容可以查看 [github](https://github.com/okx/go-wallet-sdk/tree/main/coins/zkspace) 文档。\n\n## 测试用例[#](#测试用例)\n\n在 github 上，每个模块对应的 package 下有一个 `tests` 目录，放有各个币种模块的测试用例，可以通过测试用例了解到更多关于 SDK 中函数的用法。\n\n币种\n\n测试用例\n\nBTC\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/bitcoin/psbt_tx_test.go)\n\nETH\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/ethereum/eth_test.go)\n\nCosmos\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/cosmos/atom/atom_test.go)\n\nAptos\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/aptos/aptos_test.go)\n\nEOS\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/eos/tx_test.go)\n\nSolana\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/solana/sol_test.go)\n\nStacks\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/stacks/stack_test.go)\n\nStarknet\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/starknet/account_test.go)\n\nSui\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/sui/sui_test.go)\n\nTron\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/tron/tron_test.go)\n\nZkspace\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/zkspace/account_test.go)\n\nFlow\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/flow/account_test.go)\n\nNear\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/near/transaction_test.go)\n\nPolkadot\n\n[测试用例](https://github.com/okx/go-wallet-sdk/blob/main/coins/polkadot/polkadot_test.go)\n\n## 支持币种[#](#支持币种)\n\n币族\n\n币种\n\n派生路径\n\nBTC\n\nBTC\n\n常规地址：  \nm/44'/0'/0/0'/0  \n隔离见证：  \nm/49'/0'/0/0'/0  \nm/84'/0'/0/0'/0  \nm/86'/0'/0/0'/0\n\nBTC\n\nBCH\n\nm/44'/145'/0'/0/0\n\nBTC\n\nBSV\n\nm/44'/236'/0'/0/0\n\nBTC\n\nLTC\n\nm/44'/2'/0'/0/0\n\nBTC\n\nDoge\n\nm/44'/3'/0'/0/0\n\nBTC\n\nTBTC\n\nm/44'/0'/0/0'/0\n\nBTC\n\nOmni usdt\n\nm/44'/0'/0/0'/0\n\nETH\n\nETH\n\nm/44'/60'/0'/0/0\n\nETH\n\nArbitrum One\n\nm/44'/60'/0'/0/0\n\nETH\n\nArbitrum Nova\n\nm/44'/60'/0'/0/0\n\nETH\n\nAvalanche C\n\nm/44'/60'/0'/0/0\n\nETH\n\nBoba\n\nm/44'/60'/0'/0/0\n\nETH\n\nBNB Chain\n\nm/44'/60'/0'/0/0\n\nETH\n\nBase\n\nm/44'/60'/0'/0/0\n\nETH\n\nCore\n\nm/44'/60'/0'/0/0\n\nETH\n\nCronos(EVM)\n\nm/44'/60'/0'/0/0\n\nETH\n\nCelo\n\nm/44'/60'/0'/0/0\n\nETH\n\nConflux(EVM)\n\nm/44'/60'/0'/0/0\n\nETH\n\nEndurance\n\nm/44'/60'/0'/0/0\n\nETH\n\nEthereumPoW\n\nm/44'/60'/0'/0/0\n\nETH\n\nEthereumFair\n\nm/44'/60'/0'/0/0\n\nETH\n\nFilecoin EVM\n\nm/44'/60'/0'/0/0\n\nETH\n\nFantom\n\nm/44'/60'/0'/0/0\n\nETH\n\nFlare\n\nm/44'/60'/0'/0/0\n\nETH\n\nGnosis\n\nm/44'/60'/0'/0/0\n\nETH\n\nGoerli\n\nm/44'/60'/0'/0/0\n\nETH\n\nHAQQ Network\n\nm/44'/60'/0'/0/0\n\nETH\n\nKlaytn\n\nm/44'/60'/0'/0/0\n\nETH\n\nKCC\n\nm/44'/60'/0'/0/0\n\nETH\n\nKava EVM\n\nm/44'/60'/0'/0/0\n\nETH\n\nLinea\n\nm/44'/60'/0'/0/0\n\nETH\n\nMetis\n\nm/44'/60'/0'/0/0\n\nETH\n\nMoonebeam\n\nm/44'/60'/0'/0/0\n\nETH\n\nMoonriver\n\nm/44'/60'/0'/0/0\n\nETH\n\nMantle\n\nm/44'/60'/0'/0/0\n\nETH\n\nOmega Network\n\nm/44'/60'/0'/0/0\n\nETH\n\nOKTC\n\nm/44'/60'/0'/0/0\n\nETH\n\nOptimism\n\nm/44'/60'/0'/0/0\n\nETH\n\nopBNB\n\nm/44'/60'/0'/0/0\n\nETH\n\nPolygon\n\nm/44'/60'/0'/0/0\n\nETH\n\nPolygon zkEVM\n\nm/44'/60'/0'/0/0\n\nETH\n\nPulseChain\n\nm/44'/60'/0'/0/0\n\nETH\n\nSepolia\n\nm/44'/60'/0'/0/0\n\nETH\n\nzkSync Era\n\nm/44'/60'/0'/0/0\n\nETH\n\nZetaChian\n\nm/44'/60'/0'/0/0\n\nCosmos\n\nAtom\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nAxelar\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nCronos\n\nm/44'/394'/0'/0/0\n\nCosmos\n\nOsmos\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nEvmos\n\nm/44'/60'/0'/0/0\n\nCosmos\n\nIris\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nJuno\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nKava\n\nm/44'/459'/0'/0/0\n\nCosmos\n\nKujira\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nSecret\n\nm/44'/529'/0'/0/0\n\nCosmos\n\nSei\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nStargaze\n\nm/44'/118'/0'/0/0\n\nCosmos\n\nTerra\n\nm/44'/330'/0'/0/0\n\nAptos\n\nAptos\n\nm/44'/637'/0'/0/0\n\nEOS\n\nEOS\n\nm/44'/194'/0'/0/0\n\nSolana\n\nSolana\n\nm/44'/501'/0'/0/0\n\nStacks\n\nStacks\n\nm/44'/5757'/0'/0/0\n\nETH layer 2\n\nStarknet\n\nm/44'/9004'/0'/0/0\n\nSUI\n\nSUI\n\nm/44'/784'/0'/0/0\n\nTRX\n\nTRON\n\nm/44'/195'/0'/0/0\n\nETH layer 2\n\nZKSpace\n\nm/44'/60'/0'/0/0\n\nETH layer 2\n\nzkSync\n\nm/44'/60'/0'/0/0\n\n[\n\nJavascript 签名 SDK\n\n](/zh-hans/build/dev-docs/dex-api/private-key-wallet-javascript-sdk)[\n\n什么是连接钱包\n\n](/zh-hans/build/dev-docs/sdks/okx-wallet-integration-introduction)\n\n目录\n\n[概述](#概述)[安装和构建](#安装和构建)[主要功能](#主要功能)[Packages](#packages)[测试用例](#测试用例)[支持币种](#支持币种)"
    }
  }
}
